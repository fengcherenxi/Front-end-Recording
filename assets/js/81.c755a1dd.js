(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{664:function(v,_,i){"use strict";i.r(_);var e=i(17),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h2",{attrs:{id:"_1-模块机制"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-模块机制"}},[v._v("#")]),v._v(" 1. 模块机制")]),v._v(" "),i("h3",{attrs:{id:"_1-1-commonjs规范"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-commonjs规范"}},[v._v("#")]),v._v(" 1.1 CommonJS规范")]),v._v(" "),i("ul",[i("li",[v._v("web1.0时代：表单验证&&网页特效")]),v._v(" "),i("li",[v._v("web2.0时代：工具类库、组件库、前端框架、前端应用")]),v._v(" "),i("li",[v._v("但JS先天缺乏的功能——模块\n"),i("ul",[i("li",[v._v("没有标准接口：对接服务器和数据库")]),v._v(" "),i("li",[v._v("缺乏包管理系统：JS应用没有自动加载和安装依赖的功能")])])]),v._v(" "),i("li",[v._v("因此提出CommonJS规范让JS能在任何地方运行\n"),i("ul",[i("li",[v._v("服务端JS应用程序")]),v._v(" "),i("li",[v._v("命令行工具")]),v._v(" "),i("li",[v._v("桌面图形界面应用程序")]),v._v(" "),i("li",[v._v("混合应用")])])]),v._v(" "),i("li",[v._v("模块规范：模块的定义简单。意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。同时不用担心变量污染问题。\n"),i("ul",[i("li",[v._v("模块引用——require")]),v._v(" "),i("li",[v._v("模块定义")]),v._v(" "),i("li",[v._v("模块标识")])])])]),v._v(" "),i("h3",{attrs:{id:"_1-2-node的模块实现"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-node的模块实现"}},[v._v("#")]),v._v(" 1.2 Node的模块实现")]),v._v(" "),i("ul",[i("li",[v._v("Node中引入模块：\n"),i("ul",[i("li",[v._v("(1) 路径分析(2) 文件定位(3) 编译执行")]),v._v(" "),i("li",[v._v("核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。")]),v._v(" "),i("li",[v._v("文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。")])])]),v._v(" "),i("li",[v._v("模块加载过程:\n"),i("ul",[i("li",[v._v("优先从缓存加载:对引入过的模块都会进行缓存,Node缓存的是编译和执行之后的对象。核心模块的缓存检查先于文件模块的缓存检查。")]),v._v(" "),i("li",[v._v("路径分析:\n"),i("ul",[i("li",[v._v("核心模块，如http、fs、path等——核心模块的优先级仅次于缓存加载。在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。")]),v._v(" "),i("li",[v._v("．或．．相对路径文件模块;以/开始的绝对路径文件模块；")]),v._v(" "),i("li",[v._v("非路径形式的文件模块，如自定义的connect模块——可能是一个文件或者包的形式。这类模块的查找是"),i("strong",[v._v("最慢")]),v._v("的一种。"),i("strong",[v._v("原因")]),v._v("：沿路径向上逐级递归，直到根目录下的node_modules目录。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。")])])]),v._v(" "),i("li",[v._v("文件定位：\n"),i("ul",[i("li",[v._v("细节：文件扩展名的分析、目录和包的处理")]),v._v(" "),i("li",[v._v("扩展名：不写Node会自动按．js、.json、.node的次序补足扩展名，依次尝试。诀窍是：如果是．node和．json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。")]),v._v(" "),i("li",[v._v("目录分析和包：首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。")])])]),v._v(" "),i("li",[v._v("模块编译：\n"),i("ul",[i("li",[v._v("对自定义的扩展名进行特殊的加载，可以通过类似require.extensions['.ext']的方式实现。官方不鼓励通过这种方式来进行自定义扩展名的加载，而是期望先将其他语言或文件编译成JavaScript文件后再加载，这样做的好处在于不将烦琐的编译加载等过程引入Node的执行过程中。")]),v._v(" "),i("li",[v._v("JavaScript模块的编译：包装了require、exports、module这3个变量、__filename、__dirname这两个变量")]),v._v(" "),i("li",[v._v("C/C++模块的编译：Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。——没有什么不是加一层不能解决的。——劣势则是C/C++模块的编写门槛比JavaScript高。")]),v._v(" "),i("li",[v._v("JSON文件的编译——fs模块同步读取JSON内容，调用JSON.parse()得到对象，将其赋给模块对象的exports，以供外部调用。")])])])])])]),v._v(" "),i("h3",{attrs:{id:"_1-3-核心模块"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-核心模块"}},[v._v("#")]),v._v(" 1.3 核心模块")]),v._v(" "),i("p",[v._v("Node的核心模块在编译成可执行文件的过程中被编译进了二进制文件。核心模块其实分为C/C++编写的和JavaScript编写的两部分，其中C/C++文件存放在Node项目的src目录下，JavaScript文件存放在lib目录下。")]),v._v(" "),i("ul",[i("li",[v._v("JavaScript核心模块的编译过程：\n"),i("ul",[i("li",[v._v("转存为C/C++代码：采用了V8附带的js2c.py工具，将所有内置的JavaScript代码（src/node.js和lib/*.js）转换成C++里的数组，生成node_natives.h头文件")]),v._v(" "),i("li",[v._v("编译JavaScript核心模块")])])]),v._v(" "),i("li",[v._v("C/C++核心模块的编译过程：C++模块主内完成核心，JavaScript主外实现封装的模式是Node能够提高性能的常见方式。Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的。\n"),i("ul",[i("li",[v._v("内建模块的组织形式：优势在于本身由C/C++编写，性能上优于脚本语言；其次，被编译进二进制文件。Node执行时被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接就可执行。")]),v._v(" "),i("li",[v._v("C/C++模块通过预先编译为．node文件，然后调用process.dlopen()方法加载执行。")]),v._v(" "),i("li",[v._v("内建模块的导出：node的所有模块类型中存在一种依赖层级关系（内建模块C/C++——核心模块JS——文件模块）\n"),i("ul",[i("li",[v._v("Node在启动时，会生成一个全局变量process，并提供Binding()方法来协助加载内建模块。")])])])])]),v._v(" "),i("li",[v._v("核心模块的引入流程："),i("img",{attrs:{src:"img/os.png",alt:"os原生模块的引入流程"}})]),v._v(" "),i("li",[v._v("编写核心模块：详见书本。可以通过JS来编写简单模块，也可以编写C/C++模块")])]),v._v(" "),i("h3",{attrs:{id:"_1-4-c-c-扩展模块"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-c-c-扩展模块"}},[v._v("#")]),v._v(" 1.4 C/C++扩展模块")]),v._v(" "),i("p",[v._v("JavaScript的一个典型弱点就是位运算。JavaScript的位运算参照Java的位运算实现，但是Java位运算是在int型数字的基础上进行的，而JavaScript中只有double型的数据类型，在进行位运算的过程中，需要将double型转换为int型，然后再进行。所以，在JavaScript层面上做位运算的效率不高。")]),v._v(" "),i("p",[v._v("应用中会频繁出现位运算的需求，包括转码、编码等过程，JS实现其CPU资源将会耗费很多，编写C/C++扩展模块可以有效的提升性能。")]),v._v(" "),i("p",[v._v("一个平台下的．node文件在另一个平台下是无法加载执行的，必须重新用各自平台下的编译器编译为正确的．node文件。\n"),i("img",{attrs:{src:"img/%E6%89%A9%E5%B1%95%E6%A8%A1%E5%9D%97%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png",alt:"扩展模块不同平台上的编译和加载过程"}})]),v._v(" "),i("ul",[i("li",[v._v("前提条件:  V8引擎C++库、libuv库、Node内部库、其他库")]),v._v(" "),i("li",[v._v("C/C++扩展模块的编写：\n"),i("ul",[i("li",[v._v("普通的扩展模块与内建模块的区别在于无须将源代码编译进Node，而是通过dlopen()方法动态加载。所以在编写普通的扩展模块时，无须将源代码写进node命名空间，也不需要提供头文件。")]),v._v(" "),i("li",[v._v("由于不像编写内建模块那样将对象声明到node_module_list链表中，所以无法被认作是一个原生模块，只能通过dlopen()来动态加载，然后导出给JavaScript调用。")])])]),v._v(" "),i("li",[v._v("C/C++扩展模块的编译：在GYP工具的帮助下")]),v._v(" "),i("li",[v._v("C/C++扩展模块的加载：\n"),i("ul",[i("li",[i("img",{attrs:{src:"img/require%E5%BC%95%E5%85%A5.ndoe%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B.png",alt:"require引入.ndoe文件的过程"}})]),v._v(" "),i("li",[v._v("C/C++扩展模块与JavaScript模块的区别在于加载之后不需要编译，直接执行之后就可以被外部调用了，其加载速度比JavaScript模块略快。")])])])]),v._v(" "),i("p",[v._v("备注：node-gyp工具的更多细节可以参见https://github.com/TooTallNate/node-gyp")]),v._v(" "),i("h3",{attrs:{id:"_1-5-模块调用栈"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-模块调用栈"}},[v._v("#")]),v._v(" 1.5 模块调用栈")]),v._v(" "),i("p",[v._v("文件模块、核心模块、内建模块、C/C++扩展模块之间的调用关系：\n"),i("img",{attrs:{src:"img/%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.png",alt:"调用关系"}})]),v._v(" "),i("p",[v._v("C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。如果你不是非常了解要调用的C/C++内建模块，请尽量避免通过process.binding()方法直接调用，这是不推荐的。")]),v._v(" "),i("p",[v._v("JavaScript核心模块主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要。")]),v._v(" "),i("p",[v._v("文件模块通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块。")]),v._v(" "),i("h3",{attrs:{id:"_1-6-包与npm"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-包与npm"}},[v._v("#")]),v._v(" 1.6 包与NPM")]),v._v(" "),i("p",[v._v("JavaScript不似Java或者其他语言那样，具有模块和包结构。Node对模块规范的实现，一定程度上解决了变量依赖、依赖关系等代码组织性问题。")]),v._v(" "),i("p",[i("img",{attrs:{src:"img/%E5%8C%85%E7%BB%84%E7%BB%87%E6%A8%A1%E5%9D%97.png",alt:"包组织模块"}})]),v._v(" "),i("p",[v._v("CommonJS的包规范的定义其实也十分简单，它由包结构和包描述文件两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。")]),v._v(" "),i("ul",[i("li",[v._v("包结构：包实际上是一个存档文件，即一个目录直接打包为．zip或tar.gz格式的文件，安装后解压还原为目录\n"),i("ul",[i("li",[v._v("❑ package.json：包描述文件。")]),v._v(" "),i("li",[v._v("❑ bin：用于存放可执行二进制文件的目录。")]),v._v(" "),i("li",[v._v("❑ lib：用于存放JavaScript代码的目录。")]),v._v(" "),i("li",[v._v("❑ doc：用于存放文档的目录。")]),v._v(" "),i("li",[v._v("❑ test：用于存放单元测试用例的代码。")])])]),v._v(" "),i("li",[v._v("包描述文件与NPM:\n"),i("ul",[i("li",[v._v('package.json必需的字段:name, description, version, keywords, maintainers——如"maintainers": [{ "name":"Jackson Tian", "email": "shyvo1987@gmail.com", "web":"http://html5ify.com" }]npm通过maintainers进行权限验证, contributors, bugs, license, repositories(托管源码的位置), dependencies(当前包所需要的依赖包列表)')]),v._v(" "),i("li",[v._v("可选字段：scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。如install、uninstall、build、doc、test")]),v._v(" "),i("li",[v._v("NPM常用功能：\n"),i("ul",[i("li",[v._v("查看帮助")]),v._v(" "),i("li",[v._v("安装依赖包——全局模式安装：-g全局模式其实并不精确，实际上-g是将一个包安装为全局可用的可执行命令。根据包描述文件中的bin字段配置，将实际脚本链接到node可执行文件相同的路径下；本地安装：只需为NPM指明package.json文件所在的位置即可；从非官方源安装：可以通过镜像源安装，使用过程中如果都采用镜像源安装，可执行"),i("code",[v._v("npm config set registry http://registry.url")]),v._v("命令指定默认源")]),v._v(" "),i("li",[v._v("npm钩子命令：scripts字段的提出就是让包在安装或者卸载等过程中提供钩子机制")]),v._v(" "),i("li",[v._v("发布包：初始化包描述文件——注册包仓库账号——上传包——即可安装包——管理包权限——分析包")])])]),v._v(" "),i("li",[v._v("局域NPM：考虑到模块保密性的问题，现有的解决方案就是企业搭建自己的NPM仓库。局域NPM仓库的搭建方法与搭建镜像站几乎一致。不同之处在于，可以混合使用官方仓库和居于仓库搭建项目。")])])])]),v._v(" "),i("h3",{attrs:{id:"_1-7-前后端公用模块"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-前后端公用模块"}},[v._v("#")]),v._v(" 1.7 前后端公用模块")]),v._v(" "),i("p",[v._v("JS在node出现后的优势即一些模块可以在前后端实现共用，这是因为很多API在各个宿主环境下都提供。但是在实际情况中，前后端的环境是略有差别的。")]),v._v(" "),i("ul",[i("li",[v._v("模块的侧重点：前端读取数据的瓶颈在于带宽，后端服务器的瓶颈则在于CPU和内存等资源。前者需要通过网络加载代码，后者从磁盘中加载，两者的加载速度不在一个数量级上。如果前端模块也采用同步的方式来引入，那将会在用户体验上造成很大的问题。UI在初始化过程中需要花费很多时间来等待脚本加载完成。")])]),v._v(" "),i("h2",{attrs:{id:"_2-异步i-o"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-异步i-o"}},[v._v("#")]),v._v(" 2. 异步I/O")]),v._v(" "),i("p",[v._v("PHP语言从头到脚都是以同步阻塞的方式来执行的。它的缺点在小规模站点中基本不存在，但是在复杂的网络应用中，阻塞导致它无法更好地并发。在众多高级编程语言或运行平台中，将异步作为主要编程方式和设计理念的，Node是首个。")]),v._v(" "),i("p",[v._v("Node却是全方位的，既可以作为服务器端去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用进行并发请求。")]),v._v(" "),i("h3",{attrs:{id:"_2-1-为什么要异步i-o"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-为什么要异步i-o"}},[v._v("#")]),v._v(" 2.1 为什么要异步I/O")]),v._v(" "),i("ul",[i("li",[v._v("用户体验：\n"),i("ul",[i("li",[v._v("如果脚本的执行时间超过100毫秒，用户就会感到页面卡顿，以为网页停止响应。而采用异步请求，在下载资源期间，JavaScript和UI的执行都不会处于等待状态，可以继续响应用户的交互行为，给用户一个鲜活的页面。")]),v._v(" "),i("li",[v._v("随着网站或应用不断膨胀，数据将会分布到多台服务器上，分布式将会是常态。")])])]),v._v(" "),i("li",[v._v("资源分配\n"),i("ul",[i("li",[v._v("单线程同步编程模型会因阻塞I/O导致硬件资源得不到更优的使用。多线程编程模型也因为编程中的死锁、状态同步等问题让开发人员头疼。")]),v._v(" "),i("li",[v._v("Node在两者之间给出了它的方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞，以更好地使用CPU。")]),v._v(" "),i("li",[v._v("为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I/O。 "),i("img",{attrs:{src:"img/%E5%BC%82%E6%AD%A5IO.png",alt:"异步IO"}})])])])]),v._v(" "),i("h3",{attrs:{id:"_2-2-异步i-o实现现状"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-异步i-o实现现状"}},[v._v("#")]),v._v(" 2.2 异步I/O实现现状")]),v._v(" "),i("ul",[i("li",[v._v("异步I/O与非阻塞I/O：非阻塞I/O返回之后，CPU时间片可以用来处理其他事物，性能提升是明显的。但也存在问题，立即返回的不是业务层期望的数据，而仅仅是当前调用的状态。为获得完整的数据，应用程序需要重复调用I/O操作来确认是否完成，这种重复调用判断操作是否完成的技术叫做轮询。也是对CPU资源的浪费\n"),i("ul",[i("li",[v._v("epoll是Linux下效率最高的I/O事件通知机制。真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高，CPU处理休眠的状态。")])])]),v._v(" "),i("li",[v._v("理想的非阻塞异步I/O：CPU在I/O过程中不是轮询或休眠状态，而是真正的处理其他操作")]),v._v(" "),i("li",[v._v("现实的异步I/O：采用线程池与阻塞I/O模拟异步I/O"),i("img",{attrs:{src:"img/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E6%8B%9F%E5%BC%82%E6%AD%A5.png",alt:"线程池模拟异步I/O"}})])]),v._v(" "),i("p",[v._v("基于libuv的架构示意：\n"),i("img",{attrs:{src:"img/%E5%9F%BA%E4%BA%8Elibuv%E7%9A%84%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F.png",alt:"基于libuv的架构示意"}})]),v._v(" "),i("p",[v._v("注意：另一个需要强调的地方在于我们时常提到Node是单线程的，"),i("strong",[v._v("这里的单线程仅仅只是JS执行在单线程中罢了")]),v._v("。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的另有线程池。")]),v._v(" "),i("h3",{attrs:{id:"_2-3-node的异步i-o"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-node的异步i-o"}},[v._v("#")]),v._v(" 2.3 Node的异步I/O")]),v._v(" "),i("p",[v._v("完成整个异步I/O环节的有事件循环、观察者和请求对象等。")]),v._v(" "),i("ul",[i("li",[v._v("事件循环：\n"),i("img",{attrs:{src:"img/Trick%E6%B5%81%E7%A8%8B.png",alt:"Trick流程"}})])]),v._v(" "),i("p",[v._v("进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。")]),v._v(" "),i("ul",[i("li",[v._v("观察者:在每个Tick的过程中，如何判断是否有事件需要处理呢？这里必须要引入的概念是观察者。\n"),i("ul",[i("li",[v._v("有一个或者多个（可类比收银台小妹），一个观察者里可能有多个事件。")]),v._v(" "),i("li",[v._v("在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。")]),v._v(" "),i("li",[v._v("事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。在Windows下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。")])])]),v._v(" "),i("li",[v._v("请求对象：从JS发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做请求对象。以fs.open()方法来作为例子：\n"),i("ul",[i("li",[i("img",{attrs:{src:"img/fs%E8%B0%83%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png",alt:"调用示意图"}})]),v._v(" "),i("li",[v._v("从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用，这是Node里经典的调用方式。libuv作为封装层，有两个平台的实现，实质上是调用了uv_fs_open()方法。在uv_fs_open()的调用中创建了一个FSReqWrap请求对象。其中我们最为关注的回调函数则被设置在这个对象的oncomplete_sym属性上。对象包装完毕后，在Windows下，则调用QueueUserWorkItem()方法将这个FSReqWrap对象推入线程池中等待执行")]),v._v(" "),i("li",[v._v("至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。JavaScript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管它是否阻塞I/O，都不会影响到JavaScript线程的后续执行，如此就达到了异步的目的。")]),v._v(" "),i("li",[v._v("请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。")])])]),v._v(" "),i("li",[v._v("执行回调：组装好请求对象、送入I/O线程池等待执行，实际上完成了异步I/O的第一部分，回调通知是第二部分。\n"),i("ul",[i("li",[v._v("在这个过程中，我们其实还动用了事件循环的I/O观察者。在每次Tick的执行中，它会调用IOCP相关的GetQueuedCompletionStatus()方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。")]),v._v(" "),i("li",[i("img",{attrs:{src:"img/%E6%95%B4%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%9A%84%E6%B5%81%E7%A8%8B.png",alt:"整个异步I/O的流程"}})]),v._v(" "),i("li",[v._v("事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。\\")])])]),v._v(" "),i("li",[v._v("小结：在Node中，除了JavaScript是单线程外，Node自身其实是多线程的，只是I/O线程使用的CPU较少。另一个需要重视的观点则是，除了用户代码无法并行执行外，所有的I/O（磁盘I/O和网络I/O等）则是可以并行起来的。")])]),v._v(" "),i("h3",{attrs:{id:"_2-4-非i-o的异步api"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-非i-o的异步api"}},[v._v("#")]),v._v(" 2.4 非I/O的异步API")]),v._v(" "),i("p",[v._v("Node中其实还存在一些与I/O无关的异步API：setTimeout()、setInterval()、setImmediate()和process.nextTick()")]),v._v(" "),i("ul",[i("li",[v._v("定时器：实现原理与异步I/O比较类似，只是不需要I/O线程池的参与。譬如通过setTimeout()设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的CPU时间片，再次轮到定时器执行时，时间就已经过期4毫秒。")]),v._v(" "),i("li",[v._v("process.nextTick():每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n)),nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效。")]),v._v(" "),i("li",[v._v("setImmediate():process.nextTick()中的回调函数执行的优先级要高于setImmediate()。\n"),i("ul",[i("li",[v._v("原因：事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者>check观察者。")]),v._v(" "),i("li",[v._v("process.nextTick()的回调保存在数组中，setImmediate()的结果则是保存在链表中。行为上process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。")])])])]),v._v(" "),i("h3",{attrs:{id:"_2-5-事件驱动与高性能服务器"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-事件驱动与高性能服务器"}},[v._v("#")]),v._v(" 2.5 事件驱动与高性能服务器")]),v._v(" "),i("p",[i("img",{attrs:{src:"img/%E5%88%A9%E7%94%A8Node%E6%9E%84%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png",alt:"利用Node构建Web服务器流程图"}})]),v._v(" "),i("p",[v._v("Node通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是Node高性能的一个原因。")]),v._v(" "),i("p",[v._v("Nginx采用纯C写成，性能较高，但是它仅适合于做Web服务器，用于反向代理或负载均衡等服务，在处理具体业务方面较为欠缺。Node则是一套高性能的平台，可以利用它构建与Nginx相同的功能，也可以处理各种具体业务，而且与背后的网络保持异步畅通。两者相比，Node没有Nginx在Web服务器方面那么专业，但场景更大，自身性能也不错。在实际项目中，我们可以结合它们各自优点，以达到应用的最优性能。")]),v._v(" "),i("h3",{attrs:{id:"_2-6-总结"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-总结"}},[v._v("#")]),v._v(" 2.6 总结")]),v._v(" "),i("p",[v._v("本章介绍了异步I/O和另一些非I/O的异步方法。事件循环是异步实现的核心，它与浏览器中的执行模型基本保持了一致。Node正是依靠构建了一套完善的高性能异步I/O框架，打破了JavaScript在服务器端止步不前的局面。")]),v._v(" "),i("h2",{attrs:{id:"_3-异步编程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-异步编程"}},[v._v("#")]),v._v(" 3. 异步编程")]),v._v(" "),i("p",[v._v("V8和异步I/O在性能上带来的提升，前后端JavaScript编程风格一致，是Node能够迅速成功并流行起来的主要原因。")]),v._v(" "),i("h3",{attrs:{id:"_3-1-函数式编程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-函数式编程"}},[v._v("#")]),v._v(" 3.1 函数式编程")]),v._v(" "),i("ul",[i("li",[v._v("高阶函数：把函数作为参数，或是将函数作为返回值的函数。\n"),i("ul",[i("li",[v._v("数组的sort()方法，可接受一个方法作为参数参与运算排序")]),v._v(" "),i("li",[v._v("ECMAScript5中提供的一些数组方法（forEach()、map()、reduce()、reduceRight()、filter()、every()、some()）十分典型。")])])]),v._v(" "),i("li",[v._v("偏函数用法：")])])])}),[],!1,null,null,null);_.default=t.exports}}]);