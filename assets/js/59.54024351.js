(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{640:function(t,e,a){"use strict";a.r(e);var s=a(17),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("ul",[a("li",[t._v("路由是为了实现SPA应用")]),t._v(" "),a("li",[t._v("后端路由：\n"),a("ul",[a("li",[t._v("理解：value是function，用于处理客户端提交的请求")]),t._v(" "),a("li",[t._v("工作流程：服务器接收到请求时，根据请求路径找到匹配的函数处理请求，返回相应数据")])])]),t._v(" "),a("li",[t._v("前端路由：\n"),a("ul",[a("li",[t._v("理解：value是component，用于展示页面内容")]),t._v(" "),a("li",[t._v("工作过程：当浏览器路径改变时，匹配显示对应的组件")])])]),t._v(" "),a("li",[t._v("vue router4——vue3；vue router3——vue2")]),t._v(" "),a("li",[t._v("router-link最终也转成了a标签，实现路由切换；router-view实现指定组件的呈现位置")])]),t._v(" "),a("h2",{attrs:{id:"_1-vue-router-懒加载如何实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-router-懒加载如何实现"}},[t._v("#")]),t._v(" 1. Vue-Router 懒加载如何实现")]),t._v(" "),a("p",[t._v("非懒加载：")]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("import List from '@/components/list.vue'\nconst router = new VueRouter({\n  routes: [\n    { path: '/list', component: List }\n  ]\n})\n")])])]),a("h3",{attrs:{id:"_1-1-使用箭头函数-import动态加载-常用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-使用箭头函数-import动态加载-常用"}},[t._v("#")]),t._v(" 1.1 使用箭头函数+import动态加载(常用)")]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("const List = () => import('@/components/list.vue')\nconst router = new VueRouter({\n  routes: [\n    { path: '/list', component: List }\n  ]\n})\n")])])]),a("h3",{attrs:{id:"_1-2-使用箭头函数-require动态加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-使用箭头函数-require动态加载"}},[t._v("#")]),t._v(" 1.2 使用箭头函数+require动态加载")]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("const router = new Router({\n  routes: [\n   {\n     path: '/list',\n     component: resolve => require(['@/components/list'], resolve)\n   }\n  ]\n})\n")])])]),a("h3",{attrs:{id:"_1-2-使用webpack的require-ensure技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-使用webpack的require-ensure技术"}},[t._v("#")]),t._v(" 1.2 使用webpack的require.ensure技术")]),t._v(" "),a("p",[t._v("实现按需加载。多个路由指定相同的chunkName，会合并打包成一个js文件。")]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("// r就是resolve\nconst List = r => require.ensure([], () => r(require('@/components/list')), 'list');\n// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 \nconst router = new Router({\n  routes: [\n  {\n    path: '/list',\n    component: List,\n    name: 'list'\n  }\n ]\n}))\n")])])]),a("h2",{attrs:{id:"_2-路由的hash和history模式的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-路由的hash和history模式的区别"}},[t._v("#")]),t._v(" 2. 路由的hash和history模式的区别")]),t._v(" "),a("p",[t._v("默认的路由模式是hash模式。")]),t._v(" "),a("h3",{attrs:{id:"_2-1-hash模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-hash模式"}},[t._v("#")]),t._v(" 2.1. hash模式")]),t._v(" "),a("p",[a("strong",[t._v("简介：")]),t._v(" URL带#，例如：http://www.abc.com/#/vue，它的hash值就是"),a("code",[t._v("#/vue")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("特点")]),t._v("：hash值会出现在URL里面，但是不出现在HTTP请求中，对后端没有影响。改变hash值不重新载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，SPA标配。")]),t._v(" "),a("p",[a("strong",[t._v("原理：")]),t._v(" hash模式的主要原理就是"),a("strong",[t._v("onhashchange()事件")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("window.onhashchange = function(event){\n    console.log(event.oldURL, event.newURL);\n    let hash = location.hash.slice(1);\n}\n")])])]),a("p",[t._v("使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。")]),t._v(" "),a("h3",{attrs:{id:"_2-2-history模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-history模式"}},[t._v("#")]),t._v(" 2.2 history模式")]),t._v(" "),a("p",[a("strong",[t._v("简介：")]),t._v(" history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。")]),t._v(" "),a("p",[a("strong",[t._v("特点：")]),t._v(" 当使用history模式时，URL就像这样：http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。")]),t._v(" "),a("p",[a("strong",[t._v("API：")]),t._v(" history api可以分为两大部分，切换历史状态和修改历史状态：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("修改历史状态")]),t._v("：包括了 HTML5 History Interface 中新增的 "),a("code",[t._v("pushState()")]),t._v(" 和 "),a("code",[t._v("replaceState()")]),t._v(" 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。")]),t._v(" "),a("li",[a("strong",[t._v("切换历史状态：")]),t._v(" 包括"),a("code",[t._v("forward()")]),t._v("、"),a("code",[t._v("back()")]),t._v("、"),a("code",[t._v("go()")]),t._v("三个方法，对应浏览器的前进，后退，跳转操作。")])]),t._v(" "),a("p",[t._v("虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。")]),t._v(" "),a("p",[t._v("如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n})\n")])])]),a("h3",{attrs:{id:"_2-3-两种模式对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-两种模式对比"}},[t._v("#")]),t._v(" 2.3. 两种模式对比")]),t._v(" "),a("p",[t._v("调用 history.pushState() 相比于直接修改 hash，存在以下优势:")]),t._v(" "),a("ul",[a("li",[t._v("pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；")]),t._v(" "),a("li",[t._v("pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；")]),t._v(" "),a("li",[t._v("pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；")]),t._v(" "),a("li",[t._v("pushState() 可额外设置 title 属性供后续使用。")]),t._v(" "),a("li",[t._v("hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。")])]),t._v(" "),a("h2",{attrs:{id:"_3-如何获取页面的hash变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何获取页面的hash变化"}},[t._v("#")]),t._v(" 3. 如何获取页面的hash变化")]),t._v(" "),a("h3",{attrs:{id:"_3-1-监听-route的变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-监听-route的变化"}},[t._v("#")]),t._v(" 3.1 监听$route的变化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 监听,当路由发生变化的时候执行\nwatch: {\n  $route: {\n    handler: function(val, oldVal){\n      console.log(val);\n    },\n    // 深度观察监听\n    deep: true\n  }\n},\n")])])]),a("h3",{attrs:{id:"_3-2-window-location-hash读取-值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-window-location-hash读取-值"}},[t._v("#")]),t._v(" 3.2 window.location.hash读取#值")]),t._v(" "),a("p",[t._v("window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。")]),t._v(" "),a("h2",{attrs:{id:"_4-route-和-router-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-route-和-router-的区别"}},[t._v("#")]),t._v(" 4. $route 和$router 的区别")]),t._v(" "),a("ul",[a("li",[t._v("每个组件都有自己的$route属性存储自己的路由信息；整个应用只有一个$router属性。")]),t._v(" "),a("li",[t._v("$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数")]),t._v(" "),a("li",[t._v("$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。")])]),t._v(" "),a("h2",{attrs:{id:"_5-动态路由-获取动态参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-动态路由-获取动态参数"}},[t._v("#")]),t._v(" 5. 动态路由 && 获取动态参数")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("用法")]),t._v("：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 "),a("code",[t._v("this.$route.query.name")]),t._v(" 和 "),a("code",[t._v("this.$route.params.name")]),t._v(" 。")]),t._v(" "),a("li",[a("strong",[t._v("url地址显示")]),t._v("：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示")]),t._v(" "),a("li",[a("strong",[t._v("注意")]),t._v("：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。")])]),t._v(" "),a("h3",{attrs:{id:"_5-1-param方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-param方式"}},[t._v("#")]),t._v(" 5.1 param方式")]),t._v(" "),a("ul",[a("li",[t._v("配置路由格式："),a("code",[t._v("/router/:id")])]),t._v(" "),a("li",[t._v("传递的方式：在path后面跟上对应的值，形成的路径："),a("code",[t._v("/router/123")])]),t._v(" "),a("li",[t._v("参数获取：通过 "),a("code",[t._v("$route.params.userid")]),t._v(" 获取传递的值")]),t._v(" "),a("li",[t._v("注意⚠️：使用这种方式要给路由命名\n1）路由定义")])]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("//在APP.vue中\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/user/"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("+userId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("replace")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("用户"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-link")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("    \n//在index.js\n{\n   path: '/user/:userid',\n   component: User,\n},\n")])])]),a("p",[t._v("2）路由跳转")]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("// 方法1：\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{ name: "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("users"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v(", params: { uname: wade }}"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("按钮</router-link\n\n// 方法2：\nthis.$router.push({name:'users',params:{uname:wade}})\n\n// 方法3：\nthis.$router.push('/user/' + wade)\n")])])]),a("h3",{attrs:{id:"_5-2-query方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-query方式"}},[t._v("#")]),t._v(" 5.2 query方式")]),t._v(" "),a("ul",[a("li",[t._v("配置路由格式："),a("code",[t._v("/router")]),t._v("，也就是普通配置")]),t._v(" "),a("li",[t._v("传递的方式：对象中使用query的key作为传递方式")]),t._v(" "),a("li",[t._v("传递后形成的路径："),a("code",[t._v("/route?id=123")])]),t._v(" "),a("li",[t._v("获取参数：通过"),a("code",[t._v("$route.query.userid")]),t._v(" 获取传递的值\n1）路由定义")])]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("//方式1：直接在router-link 标签上以对象的形式\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{path:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/profile"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v(",query:{name:"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("why"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v(",age:28,height:188}}"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("档案"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-link")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n// 方式2：写成按钮以点击事件形式\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("button")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("@click")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("profileClick"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("我的"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("button")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v('    \n\nprofileClick(){\n  this.$router.push({\n    path: "/profile",\n    query: {\n        name: "kobi",\n        age: "28",\n        height: 198\n    }\n  });\n}\n')])])]),a("p",[t._v("2）跳转方法")]),t._v(" "),a("div",{staticClass:"language-vue extra-class"},[a("pre",{pre:!0,attrs:{class:"language-vue"}},[a("code",[t._v("// 方法1：\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{ name: "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("users"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v(", query: { uname: james }}"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("按钮"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-link")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n// 方法2：\nthis.$router.push({ name: 'users', query:{ uname:james }})\n\n// 方法3：\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{ path: "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("/user"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v(", query: { uname:james }}"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("按钮"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-link")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n// 方法4：\nthis.$router.push({ path: '/user', query:{ uname:james }})\n\n// 方法5：\nthis.$router.push('/user?uname=' + jsmes)\n")])])]),a("h2",{attrs:{id:"_6-vue-router-路由钩子在生命周期的体现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-router-路由钩子在生命周期的体现"}},[t._v("#")]),t._v(" 6. Vue-router 路由钩子在生命周期的体现")]),t._v(" "),a("p",[t._v("一、Vue-Router导航守卫")]),t._v(" "),a("p",[t._v("有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。")]),t._v(" "),a("p",[t._v("为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的")]),t._v(" "),a("ol",[a("li",[t._v("全局路由钩子")])]),t._v(" "),a("p",[t._v("vue-router全局有三个路由钩子;")]),t._v(" "),a("ul",[a("li",[t._v("router.beforeEach 全局前置守卫 进入路由之前")]),t._v(" "),a("li",[t._v("router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用")]),t._v(" "),a("li",[t._v("router.afterEach 全局后置钩子 进入路由之后")])]),t._v(" "),a("p",[t._v("具体使用∶")]),t._v(" "),a("ul",[a("li",[t._v("beforeEach（判断是否登录了，没登录就跳转到登录页）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("router.beforeEach((to, from, next) => {  \n    let ifInfo = Vue.prototype.$common.getSession('userData');  // 判断是否登录的存储信息\n    if (!ifInfo) { \n        // sessionStorage里没有储存user信息    \n        if (to.path == '/') { \n            //如果是登录页面路径，就直接next()      \n            next();    \n        } else { \n            //不然就跳转到登录      \n            Message.warning(\"请重新登录！\");     \n            window.location.href = Vue.prototype.$loginUrl;    \n        }  \n    } else {    \n        return next();  \n    }\n})\n")])])]),a("ul",[a("li",[t._v("afterEach （跳转之后滚动条回到顶部）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("router.afterEach((to, from) => {  \n    // 跳转之后滚动条回到顶部  \n    window.scrollTo(0,0);\n});\n")])])]),a("ol",[a("li",[t._v("单个路由独享钩子")])]),t._v(" "),a("p",[a("strong",[t._v("beforeEnter")])]),t._v(" "),a("p",[t._v("如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export default [    \n    {        \n        path: '/',        \n        name: 'login',        \n        component: login,        \n        beforeEnter: (to, from, next) => {          \n            console.log('即将进入登录页面')          \n            next()        \n        }    \n    }\n]\n")])])]),a("ol",[a("li",[t._v("组件内钩子")])]),t._v(" "),a("p",[t._v("beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave")]),t._v(" "),a("p",[t._v("这三个钩子都有三个参数∶to、from、next")]),t._v(" "),a("ul",[a("li",[t._v("beforeRouteEnter∶ 进入组件前触发")]),t._v(" "),a("li",[t._v("beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用")]),t._v(" "),a("li",[t._v("beforeRouteLeave∶ 离开组件被调用")])]),t._v(" "),a("p",[t._v("注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("beforeRouteEnter(to, from, next) {      \n    next(target => {        \n        if (from.path == '/classProcess') {          \n            target.isFromProcess = true        \n        }      \n    })    \n}\n")])])]),a("p",[t._v("二、Vue路由钩子在生命周期函数的体现")]),t._v(" "),a("ol",[a("li",[t._v("完整的路由导航解析流程（不包括其他生命周期）")])]),t._v(" "),a("ul",[a("li",[t._v("触发进入其他路由。")]),t._v(" "),a("li",[t._v("调用要离开路由的组件守卫beforeRouteLeave")]),t._v(" "),a("li",[t._v("调用局前置守卫∶ beforeEach")]),t._v(" "),a("li",[t._v("在重用的组件里调用 beforeRouteUpdate")]),t._v(" "),a("li",[t._v("调用路由独享守卫 beforeEnter。")]),t._v(" "),a("li",[t._v("解析异步路由组件。")]),t._v(" "),a("li",[t._v("在将要进入的路由组件中调用 beforeRouteEnter")]),t._v(" "),a("li",[t._v("调用全局解析守卫 beforeResolve")]),t._v(" "),a("li",[t._v("导航被确认。")]),t._v(" "),a("li",[t._v("调用全局后置钩子的 afterEach 钩子。")]),t._v(" "),a("li",[t._v("触发DOM更新（mounted）。")]),t._v(" "),a("li",[t._v("执行beforeRouteEnter 守卫中传给 next 的回调函数")])]),t._v(" "),a("ol",[a("li",[t._v("触发钩子的完整顺序")])]),t._v(" "),a("p",[t._v("路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶")]),t._v(" "),a("ul",[a("li",[t._v("beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。")]),t._v(" "),a("li",[t._v("beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。")]),t._v(" "),a("li",[t._v("beforeEnter：路由独享守卫")]),t._v(" "),a("li",[t._v("beforeRouteEnter：路由组件的组件进入路由前钩子。")]),t._v(" "),a("li",[t._v("beforeResolve：路由全局解析守卫")]),t._v(" "),a("li",[t._v("afterEach：路由全局后置钩子")]),t._v(" "),a("li",[t._v("beforeCreate：组件生命周期，不能访问tAis。")]),t._v(" "),a("li",[t._v("created;组件生命周期，可以访问tAis，不能访问dom。")]),t._v(" "),a("li",[t._v("beforeMount：组件生命周期")]),t._v(" "),a("li",[t._v("deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。")]),t._v(" "),a("li",[t._v("mounted：访问/操作dom。")]),t._v(" "),a("li",[t._v("activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。")]),t._v(" "),a("li",[t._v("执行beforeRouteEnter回调函数next。")])]),t._v(" "),a("ol",[a("li",[t._v("导航行为被触发到导航完成的整个过程")])]),t._v(" "),a("ul",[a("li",[t._v("导航行为被触发，此时导航未被确认。")]),t._v(" "),a("li",[t._v("在失活的组件里调用离开守卫 beforeRouteLeave。")]),t._v(" "),a("li",[t._v("调用全局的 beforeEach守卫。")]),t._v(" "),a("li",[t._v("在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。")]),t._v(" "),a("li",[t._v("在路由配置里调用 beforeEnteY。")]),t._v(" "),a("li",[t._v("解析异步路由组件（如果有）。")]),t._v(" "),a("li",[t._v("在被激活的组件里调用 beforeRouteEnter。")]),t._v(" "),a("li",[t._v("调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。")]),t._v(" "),a("li",[t._v("导航被确认。")]),t._v(" "),a("li",[t._v("调用全局的 afterEach 钩子。")]),t._v(" "),a("li",[t._v("非重用组件，开始组件实例的生命周期：beforeCreate&created、beforeMount&mounted")]),t._v(" "),a("li",[t._v("触发 DOM 更新。")]),t._v(" "),a("li",[t._v("用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。")]),t._v(" "),a("li",[t._v("导航完成")])]),t._v(" "),a("h2",{attrs:{id:"_7-vue-router跳转和location-href区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-router跳转和location-href区别"}},[t._v("#")]),t._v(" 7. Vue-router跳转和location.href区别")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("location.href= /url")]),t._v("简单方便，但是刷新了页面；")]),t._v(" "),a("li",[a("code",[t._v("history.pushState( /url )")]),t._v(" ，无刷新页面，静态跳转；")]),t._v(" "),a("li",[t._v("引进 router ，然后使用 "),a("code",[t._v("router.push( /url )")]),t._v(" 来跳转，使用了 "),a("code",[t._v("diff")]),t._v(" 算法，实现按需加载，减少 dom 消耗。其实使用 router 跳转和使用 "),a("code",[t._v("history.pushState()")]),t._v(" 没什么差别的，因为vue-router就是用了 "),a("code",[t._v("history.pushState()")]),t._v(" ，尤其是在history模式下。")])]),t._v(" "),a("h2",{attrs:{id:"_8-vue-router-导航守卫有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-router-导航守卫有哪些"}},[t._v("#")]),t._v(" 8. Vue-router 导航守卫有哪些")]),t._v(" "),a("ul",[a("li",[t._v("全局前置/钩子：beforeEach、beforeResolve、afterEach")]),t._v(" "),a("li",[t._v("路由独享的守卫：beforeEnter")]),t._v(" "),a("li",[t._v("组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave")])]),t._v(" "),a("h2",{attrs:{id:"_9-对前端路由的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-对前端路由的理解"}},[t._v("#")]),t._v(" 9. 对前端路由的理解")]),t._v(" "),a("p",[t._v("Ajax 出现允许不刷新页面下发请求。出现了 "),a("strong",[t._v("SPA（单页面应用")]),t._v("）。")]),t._v(" "),a("p",[t._v("SPA提升用户体验，内容的切换更流畅。但诞生之初并未考虑到“定位”问题——切换前后 URL 一样，问题：")]),t._v(" "),a("ul",[a("li",[t._v("不知道页面“进展到哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。")]),t._v(" "),a("li",[t._v("由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息")])]),t._v(" "),a("p",[t._v("为解决问题前端路由出现。可在一个页面下，“记住”用户走到哪一步——为各视图匹配唯一标识。用户前进、后退触发新内容映射到不同 URL。即便刷新页面内容也不会丢失。")]),t._v(" "),a("p",[t._v("如何实现要解决两个问题：")]),t._v(" "),a("ul",[a("li",[t._v("当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。")]),t._v(" "),a("li",[t._v("单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？")])]),t._v(" "),a("p",[t._v("从这两个问题来看，服务端已经完全救不了这个场景了。所以靠前端自力更生，解决思路：")]),t._v(" "),a("ul",[a("li",[t._v("拦截用户的刷新操作，避免服务端盲目响应、返回不符的资源内容。")]),t._v(" "),a("li",[t._v("感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);