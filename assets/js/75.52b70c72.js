(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{659:function(v,_,t){"use strict";t.r(_);var a=t(17),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[t("a",{attrs:{href:"https://juejin.cn/post/6892994632968306702#heading-47",target:"_blank",rel:"noopener noreferrer"}},[v._v("更多详细性能优化"),t("OutboundLink")],1),v._v("\n简单叙述：")]),v._v(" "),t("ul",[t("li",[v._v("减少http请求")]),v._v(" "),t("li",[v._v("使用http2请求：多路复用、解析速度快、首部压缩、服务器推送、优先级控制、流量控制")]),v._v(" "),t("li",[v._v("ssr服务端渲染")]),v._v(" "),t("li",[v._v("cdn存放图片文件等静态资源")]),v._v(" "),t("li",[v._v("css头部、js尾部")]),v._v(" "),t("li",[v._v("iconfont图标代替图片图标、压缩字体")]),v._v(" "),t("li",[v._v("善用缓存")]),v._v(" "),t("li",[v._v("压缩文件gzip")]),v._v(" "),t("li",[v._v("图片优化：延迟加载、响应式图片、调整图片大小、降低质量、css3画图、webp格式")]),v._v(" "),t("li",[v._v("webpack按需加载代码")]),v._v(" "),t("li",[v._v("减少重绘重排")]),v._v(" "),t("li",[v._v("使用事件委托")]),v._v(" "),t("li",[v._v("requestAnimationFrame来实现视觉变化")]),v._v(" "),t("li",[v._v("使用webworkers")]),v._v(" "),t("li",[v._v("使用位操作")]),v._v(" "),t("li",[v._v("不覆盖原生方法（c++写的）")]),v._v(" "),t("li",[v._v("降低css选择器的复杂性")]),v._v(" "),t("li",[v._v("flex布局")]),v._v(" "),t("li",[v._v("transform和opcity属性实现动画")]),v._v(" "),t("li",[v._v("合理使用规则避免过度优化")])]),v._v(" "),t("h2",{attrs:{id:"渲染过程优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程优化"}},[v._v("#")]),v._v(" 渲染过程优化")]),v._v(" "),t("h3",{attrs:{id:"针对js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#针对js"}},[v._v("#")]),v._v(" 针对js")]),v._v(" "),t("p",[v._v("JS会阻塞渲染问题")]),v._v(" "),t("ul",[t("li",[v._v("尽量将js文件放在body的最后")]),v._v(" "),t("li",[t("code",[v._v("<script>")]),v._v("标签的引入资源尽量使用异步加载，不会阻塞DOM的解析，三者的区别如图\n"),t("ul",[t("li",[t("ul",[t("li",[t("strong",[v._v("async")]),v._v(" 是在下载完成之后，立即异步加载，加载好后立即执行，不保证顺序")])])]),v._v(" "),t("li",[t("strong",[v._v("defer")]),v._v(" 是在下载完成之后，立即异步加载。"),t("strong",[v._v("等 DOM 树解析好执行")]),v._v("。多个带defer按照"),t("strong",[v._v("顺序执行")]),v._v("。")])])])]),v._v(" "),t("h3",{attrs:{id:"针对css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#针对css"}},[v._v("#")]),v._v(" 针对css")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("link")]),v._v("：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码")]),v._v(" "),t("li",[t("strong",[v._v("@import")]),v._v("：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)")]),v._v(" "),t("li",[t("strong",[v._v("style")]),v._v("：GUI直接渲染")])]),v._v(" "),t("p",[v._v("导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。")]),v._v(" "),t("h3",{attrs:{id:"针对dom树、cssom树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#针对dom树、cssom树"}},[v._v("#")]),v._v(" 针对DOM树、CSSOM树")]),v._v(" "),t("ul",[t("li",[v._v("HTML文件的代码层级尽量不要太深——"),t("strong",[v._v("层级扁平化处理")])]),v._v(" "),t("li",[v._v("使用"),t("strong",[v._v("语义化的标签")]),v._v("，来避免不标准语义化的特殊处理")]),v._v(" "),t("li",[v._v("减少CSSD代码的层级，因为选择器是从左向右进行解析的")])]),v._v(" "),t("h3",{attrs:{id:"减少回流与重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#减少回流与重绘"}},[v._v("#")]),v._v(" 减少回流与重绘")]),v._v(" "),t("ul",[t("li",[v._v("集中改变样式，不要一条一条地修改 DOM 的样式。")]),v._v(" "),t("li",[v._v("不要把 DOM 结点的属性值放在循环里当成循环里的变量。")]),v._v(" "),t("li",[v._v("不要使用"),t("code",[v._v("table")]),v._v("布局， 一个小的改动可能会使整个"),t("code",[v._v("table")]),v._v("进行重新布局")]),v._v(" "),t("li",[v._v("使用CSS的表达式")]),v._v(" "),t("li",[v._v("不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。")]),v._v(" "),t("li",[v._v("动画的 HTML 元件使用absolute或者fixed，使元素脱离文档流，修改他们的 CSS 是不会 reflow 的；尽量只修改position：absolute或fixed元素，对其他元素影响不大")]),v._v(" "),t("li",[v._v("动画开始GPU加速，translate使用3D变化")]),v._v(" "),t("li",[v._v("避免频繁操作DOM，可以创建一个文档片段"),t("code",[v._v("documentFragment")]),v._v("，在它上面应用所有DOM操作，最后再把它添加到文档中")]),v._v(" "),t("li",[v._v("将元素先设置"),t("code",[v._v("display: none")]),v._v("，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。")]),v._v(" "),t("li",[v._v("将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于"),t("strong",[v._v("浏览器的渲染队列机制")]),v._v("。")]),v._v(" "),t("li",[v._v("提升为合成层\n"),t("ul",[t("li",[v._v("合成层的位图，会交由 GPU 合成，比 CPU 处理要快")]),v._v(" "),t("li",[v._v("当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层")]),v._v(" "),t("li",[v._v("对于 transform 和 opacity 效果，不会触发 layout 和 paint")])])])]),v._v(" "),t("p",[v._v("即浏览器针对页面的回流与重绘，进行了自身的优化——"),t("strong",[v._v("渲染队列")])]),v._v(" "),t("p",[t("strong",[v._v("浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。")])]),v._v(" "),t("h2",{attrs:{id:"优化关键渲染路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化关键渲染路径"}},[v._v("#")]),v._v(" 优化关键渲染路径？")]),v._v(" "),t("p",[v._v("为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：")]),v._v(" "),t("ul",[t("li",[v._v("关键资源的数量。")]),v._v(" "),t("li",[v._v("关键路径长度。——某些资源只能在上一资源处理完毕之后才能开始下载")]),v._v(" "),t("li",[v._v("关键字节的数量。")])]),v._v(" "),t("p",[v._v("优化关键渲染路径的常规步骤如下：")]),v._v(" "),t("ul",[t("li",[v._v("对关键路径进行分析和特性描述：资源数、字节数、长度。")]),v._v(" "),t("li",[v._v("最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。")]),v._v(" "),t("li",[v._v("优化关键字节数以缩短下载时间（往返次数）。")]),v._v(" "),t("li",[v._v("优化其余关键资源的加载顺序：需要尽早下载所有关键资产，以缩短关键路径长度")])]),v._v(" "),t("h2",{attrs:{id:"一、cdn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、cdn"}},[v._v("#")]),v._v(" 一、CDN")]),v._v(" "),t("h3",{attrs:{id:"_1-概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[v._v("#")]),v._v(" 1. 概念")]),v._v(" "),t("p",[v._v("CDN（Content Delivery Network，内容分发网络），是一组分布在多个不同地理位置的 Web 服务器。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。")]),v._v(" "),t("p",[v._v("如果用户访问的网站部署了 CDN，过程是这样的：")]),v._v(" "),t("ul",[t("li",[v._v("浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。")]),v._v(" "),t("li",[v._v("本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。")]),v._v(" "),t("li",[v._v("本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。")]),v._v(" "),t("li",[v._v("本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。")]),v._v(" "),t("li",[v._v("SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。")]),v._v(" "),t("li",[v._v("浏览器再根据 SLB 发回的地址重定向到缓存服务器。")]),v._v(" "),t("li",[v._v("如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。")])]),v._v(" "),t("h3",{attrs:{id:"_2-作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-作用"}},[v._v("#")]),v._v(" 2. 作用")]),v._v(" "),t("p",[v._v("CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。")]),v._v(" "),t("ul",[t("li",[v._v("在性能方面，引入CDN的作用在于：\n"),t("ul",[t("li",[v._v("用户收到的内容来自最近的数据中心，延迟更低，内容加载更快")]),v._v(" "),t("li",[v._v("部分资源请求分配给了CDN，减少了服务器的负载")])])]),v._v(" "),t("li",[v._v("在安全方面，CDN有助于防御DDoS、MITM等网络攻击：\n"),t("ul",[t("li",[v._v("针对DDoS：通过监控分析异常流量，限制其请求频率")]),v._v(" "),t("li",[v._v("针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信")])])]),v._v(" "),t("li",[v._v("除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。")]),v._v(" "),t("li",[v._v("任播技术，服务器域名都相同、TLS加密技术。")])]),v._v(" "),t("h3",{attrs:{id:"_3-cdn的使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-cdn的使用场景"}},[v._v("#")]),v._v(" 3. CDN的使用场景")]),v._v(" "),t("ul",[t("li",[v._v("使用第三方的CDN服务：如果想要开源一些项目，可以使用第三方的CDN服务")]),v._v(" "),t("li",[v._v("使用CDN进行静态资源的缓存：将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上。")]),v._v(" "),t("li",[v._v("直播传送：直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。")])]),v._v(" "),t("h2",{attrs:{id:"二、webpack打包资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、webpack打包资源"}},[v._v("#")]),v._v(" 二、webpack打包资源")]),v._v(" "),t("h3",{attrs:{id:"externals"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#externals"}},[v._v("#")]),v._v(" externals")]),v._v(" "),t("p",[v._v("externals可以用来防止将某些 import的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)（放到cdn服务器上，用的时候直接请求）")]),v._v(" "),t("h3",{attrs:{id:"拆包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拆包"}},[v._v("#")]),v._v(" 拆包")]),v._v(" "),t("p",[v._v("app.js进行拆包配置——按需加载的最大并行请求数等")]),v._v(" "),t("h3",{attrs:{id:"压缩js、css"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#压缩js、css"}},[v._v("#")]),v._v(" 压缩JS、CSS")]),v._v(" "),t("p",[v._v("webpack v5 或更高版本，是开箱机带的功能")]),v._v(" "),t("p",[v._v("需要安装 terser-webpack-plugin。如果使用 webpack v4，则必须安装terser-webpack-plugin v4 的版本。——去掉注释、console.log")]),v._v(" "),t("p",[v._v("在 webpack 可以使用如下插件进行压缩：")]),v._v(" "),t("ul",[t("li",[v._v("JavaScript：UglifyPlugin")]),v._v(" "),t("li",[v._v("CSS ：MiniCssExtractPlugin")]),v._v(" "),t("li",[v._v("HTML：HtmlWebpackPlugin")])]),v._v(" "),t("h3",{attrs:{id:"压缩图片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#压缩图片"}},[v._v("#")]),v._v(" 压缩图片")]),v._v(" "),t("p",[v._v("安装图片压缩的loader image-webpack-loader直接终端npm install image-webpack-loader -D")]),v._v(" "),t("h3",{attrs:{id:"gzip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gzip"}},[v._v("#")]),v._v(" gzip")]),v._v(" "),t("p",[v._v("可以通过向 HTTP 请求头中的 Accept-Encoding 头添加 gzip 标识来开启这一功能。当然，服务器也得支持这一功能。")]),v._v(" "),t("p",[v._v("打包压缩静态文件插件、对用服务端Nginx配置")]),v._v(" "),t("p",[v._v("合并多个文件一起打包（提高文件的字符重复率）")]),v._v(" "),t("h3",{attrs:{id:"增加cache-loader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#增加cache-loader"}},[v._v("#")]),v._v(" 增加cache-loader")]),v._v(" "),t("p",[v._v("只有执行时间很长的loader才适合用缓存，因为读写文件也是有开销的，滥用反而会导致变慢")]),v._v(" "),t("h2",{attrs:{id:"三、服务端渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、服务端渲染"}},[v._v("#")]),v._v(" 三、服务端渲染")]),v._v(" "),t("p",[v._v("客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。")]),v._v(" "),t("p",[v._v("服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。")]),v._v(" "),t("ul",[t("li",[v._v("优点：首屏渲染快，SEO 好。")]),v._v(" "),t("li",[v._v("缺点：配置麻烦，增加了服务器的计算压力。")])]),v._v(" "),t("p",[v._v("下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。")]),v._v(" "),t("p",[v._v("客户端渲染过程：")]),v._v(" "),t("ul",[t("li",[v._v("访问客户端渲染的网站。")]),v._v(" "),t("li",[v._v("服务器返回一个包含了引入资源语句和 "),t("div",{attrs:{id:"app"}}),v._v(" 的 HTML 文件。")]),v._v(" "),t("li",[v._v("客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面。")])]),v._v(" "),t("p",[v._v("服务端渲染过程")]),v._v(" "),t("ul",[t("li",[v._v("访问服务端渲染的网站。")]),v._v(" "),t("li",[v._v("服务器会查看当前路由组件需要哪些资源文件，然后将这些文件的内容填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面。")]),v._v(" "),t("li",[v._v("当客户端接收到这个 HTML 页面时，可以马上就开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面。")])]),v._v(" "),t("p",[v._v("从上述两个过程中可以看出，区别就在于第二步。客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件。")]),v._v(" "),t("p",[v._v("这样做的"),t("strong",[v._v("好处")]),v._v("是什么？是更快的内容到达时间 (time-to-content)。")]),v._v(" "),t("p",[v._v("假设你的网站需要加载完 abcd 四个文件才能渲染完毕。并且每个文件大小为 1 M。")]),v._v(" "),t("p",[v._v("这样一算：客户端渲染的网站需要加载 4 个文件和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件（这种文件不会太大，一般为几百K，我的个人博客网站（SSR）加载的 HTML 文件为 400K）。这就是服务端渲染更快的原因。")]),v._v(" "),t("h2",{attrs:{id:"四、按需加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、按需加载"}},[v._v("#")]),v._v(" 四、按需加载")]),v._v(" "),t("ul",[t("li",[v._v("路由、图片懒加载，第三方按需加载")]),v._v(" "),t("li",[v._v("tabs 懒加载（切换到对应tab时再渲染）")]),v._v(" "),t("li",[v._v("keep-alive缓存页面，增加访问速度")]),v._v(" "),t("li",[v._v("如果列表纯粹是显示数据，不会有改变，数据就不需要响应式，可以使用Object.freeze方法进行冻结")]),v._v(" "),t("li",[v._v("图片懒加载：先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。")])]),v._v(" "),t("p",[v._v("首先可以将图片这样设置，在页面不可见时图片不会加载：")]),v._v(" "),t("div",{staticClass:"language-html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),v._v("img")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[v._v("data-src")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[v._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')]),v._v("https://avatars0.githubusercontent.com/u/22117876?s=460&u=7bd8f32788df6988833da6bd155c3cfbebc68006&v=4"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')])]),t("span",{pre:!0,attrs:{class:"token attr-name"}},[v._v("]]")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v("\n")])])]),t("p",[v._v("等页面可见时，使用 JS 加载图片：")]),v._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),v._v(" img "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" document"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("querySelector")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v("'img'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" img"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("src "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" img"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("dataset"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("src\n")])])]),t("h2",{attrs:{id:"五、合理配置缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、合理配置缓存"}},[v._v("#")]),v._v(" 五、合理配置缓存")]),v._v(" "),t("p",[v._v("通过添加 Expires 或 max-age 来控制这一行为。Expires 设置了一个时间，只要在这个时间之前，浏览器都不会请求文件，而是直接使用缓存。而 max-age 是一个相对时间，建议使用 max-age 代替 Expires 。")]),v._v(" "),t("p",[v._v("不过这样会产生一个问题，当文件更新了怎么办？"),t("strong",[v._v("怎么通知浏览器重新请求文件？")])]),v._v(" "),t("p",[v._v("可以通过更新页面中引用的资源链接地址，让浏览器主动放弃缓存，加载新资源。")]),v._v(" "),t("p",[v._v("具体做法是把资源地址 URL 的修改与文件内容关联起来，也就是说，只有文件内容变化，才会导致相应 URL 的变更，从而实现文件级别的精确缓存控制。什么东西与文件内容相关呢？我们会很自然的联想到利用数据摘要要算法对文件求摘要信息，摘要信息与文件内容一一对应，就有了一种可以精确到单个文件粒度的缓存控制依据了。")]),v._v(" "),t("h2",{attrs:{id:"六、使用http2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、使用http2"}},[v._v("#")]),v._v(" 六、使用HTTP2")]),v._v(" "),t("p",[v._v("HTTP 2.0 增加了新的二进制分帧数据层，而这一层并不兼容之前的 HTTP 1.x 服务器及客户端——是谓 2.0。")]),v._v(" "),t("h3",{attrs:{id:"http-1-1-的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-的问题"}},[v._v("#")]),v._v(" HTTP/1.1 的问题")]),v._v(" "),t("ul",[t("li",[v._v("队头阻塞")]),v._v(" "),t("li",[v._v("低效的 TCP 利用 :TCP慢启动机制，导致每个 TCP 连接在一开始的时候传输速率都不高，在处理多个请求后，才会慢慢达到“合适”的速率。对于请求数据量很小的 HTTP 请求来说，这种情况就是种灾难。")]),v._v(" "),t("li",[v._v("臃肿的消息首部 :HTTP/1.1 的首部无法压缩，再加上 cookie 的存在，经常会出现首部大小比请求数据大小还大的情况。")]),v._v(" "),t("li",[v._v("受限的优先级设置:HTTP/1.1 无法为重要的资源指定优先级。")])]),v._v(" "),t("h3",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[v._v("#")]),v._v(" 优点")]),v._v(" "),t("ul",[t("li",[v._v("多路复用：在 HTTP/1.1 中，如果客户端想发送多个并行的请求，那么必须使用多个 TCP 连接。 而 HTTP/2 的二进制分帧层突破了这一限制，所有的请求和响应都在同一个 TCP 连接上发送：客户端和服务器把 HTTP 消息分解成多个帧，然后乱序发送，最后在另一端再根据流 ID 重新组合起来。")]),v._v(" "),t("li",[v._v("解析速度快")]),v._v(" "),t("li",[v._v("压缩头部")]),v._v(" "),t("li",[v._v("优先级：通过 HEADERS 帧和 PRIORITY 帧，客户端可以明确地和服务器沟通它需要什么，以及它需要这些资源的顺序。具体来讲，服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。")]),v._v(" "),t("li",[v._v("服务器推送")]),v._v(" "),t("li",[v._v("流量控制")]),v._v(" "),t("li",[v._v("在 HTTP/1.1 中要把多个小资源合并成一个大资源，从而减少请求。而在 HTTP/2 就不需要了，因为 HTTP/2 所有的请求都可以在一个 TCP 连接发送。")])]),v._v(" "),t("h2",{attrs:{id:"七、使用-web-workers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、使用-web-workers"}},[v._v("#")]),v._v(" 七、使用 Web Workers")]),v._v(" "),t("p",[v._v("Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个 worker 可以将消息发送到创建它的 JavaScript 代码, 通过将消息发送到该代码指定的事件处理程序（反之亦然）。")]),v._v(" "),t("p",[v._v("Web Worker 适用于那些处理纯数据，或者与浏览器 UI 无关的长时间运行脚本。")]),v._v(" "),t("h2",{attrs:{id:"八、其他"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#八、其他"}},[v._v("#")]),v._v(" 八、其他")]),v._v(" "),t("ul",[t("li",[v._v("使用字体图标 iconfont 代替图片图标")]),v._v(" "),t("li",[v._v("子组件中有一些比较耗时的就单独分割成为一个组件，自己做自己的渲染，不会影响其他的组件")]),v._v(" "),t("li",[v._v("将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);