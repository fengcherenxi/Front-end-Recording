(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{639:function(v,_,i){"use strict";i.r(_);var e=i(17),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h2",{attrs:{id:"_1-虚拟dom的理解"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-虚拟dom的理解"}},[v._v("#")]),v._v(" 1. 虚拟dom的理解")]),v._v(" "),i("ul",[i("li",[v._v("虚拟dom是js对象，很好的跨平台（比如Node.js就没有DOM），助于实现SSR")]),v._v(" "),i("li",[v._v("优点：\n"),i("ul",[i("li",[v._v("将页面的状态抽象为JS对象，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。")]),v._v(" "),i("li",[v._v("在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。（diff算法），渲染时只修改改变的变化。")]),v._v(" "),i("li",[v._v("对DOM的轻量级描述。无须手动操作DOM，一方面是保证程序性能，另一方面省略手动DOM操作可以大大提高开发效率。")])])])]),v._v(" "),i("h2",{attrs:{id:"_2-虚拟dom的解析过程"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-虚拟dom的解析过程"}},[v._v("#")]),v._v(" 2. 虚拟DOM的解析过程？")]),v._v(" "),i("p",[v._v("vue的渲染过程：\n"),i("img",{attrs:{src:"https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiMWFiMjI5MDgtNjBjZS00NGFmLWIyOTUtNjk2ZGYyY2JlNGFjIiwicmVzb3VyY0d1aWQiOiI4YWRmNWI2ZC02ZDZhLTRiMTItYWQ4Ni1jMmU4ZjZmZGQwMDEifQ==",alt:""}})]),v._v(" "),i("ul",[i("li",[v._v("分析要插入到文档中的 DOM 树结构，使用 js 表示；然后缓存 js 对象树；最后将 DOM 片段插入到文档中。")]),v._v(" "),i("li",[v._v("当页面状态改变时，首先根据变更的状态，重新构建起对象树，然后比较新旧对象树。")]),v._v(" "),i("li",[v._v("更新 DOM 树。")])]),v._v(" "),i("p",[v._v("将真实的dom转化为虚拟的dom（js对象）增加了初始化的时间；但变化更新的时候做对比更好")]),v._v(" "),i("h2",{attrs:{id:"_3-虚拟dom是如何提升vue的渲染效率的"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-虚拟dom是如何提升vue的渲染效率的"}},[v._v("#")]),v._v(" 3. 虚拟dom是如何提升vue的渲染效率的？")]),v._v(" "),i("ul",[i("li",[v._v("vue的两大核心：组件化、数据驱动")]),v._v(" "),i("li",[v._v("局部更新（节点数据）")]),v._v(" "),i("li",[v._v("将直接操作dom的地方拿到两个js对象之中去作比较")]),v._v(" "),i("li",[v._v("即：在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。")])]),v._v(" "),i("h2",{attrs:{id:"_4-虚拟dom对比真实dom性能"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_4-虚拟dom对比真实dom性能"}},[v._v("#")]),v._v(" 4. 虚拟DOM对比真实DOM性能")]),v._v(" "),i("ul",[i("li",[v._v("保证性能下限，在不进行手动优化的情况下，提供过得去的性能。在真实DOM操作的时候进行针对性的优化时，还是更快的。重排重绘的性能消耗∶\n"),i("ul",[i("li",[v._v("真实DOM∶ 生成HTML字符串＋重建所有的DOM元素")]),v._v(" "),i("li",[v._v("虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新")]),v._v(" "),i("li",[v._v("Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。")])])]),v._v(" "),i("li",[v._v("跨平台：Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。")])]),v._v(" "),i("h2",{attrs:{id:"_5-diff算法的原理"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_5-diff算法的原理"}},[v._v("#")]),v._v(" 5. DIFF算法的原理")]),v._v(" "),i("ul",[i("li",[v._v("对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换")])]),v._v(" "),i("ul",[i("li",[v._v("匹配子节点：如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)")]),v._v(" "),i("li",[v._v("更新子节点：若都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。")]),v._v(" "),i("li",[v._v("匹配时，找到相同的子节点，递归比较子节点")])]),v._v(" "),i("p",[v._v("在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。")]),v._v(" "),i("h3",{attrs:{id:"_6-vue中key的作用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue中key的作用"}},[v._v("#")]),v._v(" 6. Vue中key的作用")]),v._v(" "),i("ul",[i("li",[v._v("第一种情况 v-if 中使用 key。当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。")]),v._v(" "),i("li",[v._v("第二种情况 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，方便 Vue 跟踪元素身份，从而高效的实现复用。"),i("strong",[v._v("这个时候 key 的作用是为了高效的更新渲染虚拟 DOM")]),v._v("。")])]),v._v(" "),i("p",[v._v("key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速")]),v._v(" "),i("ul",[i("li",[v._v("更准确：因为带 key 就不是就地复用了，在 sameNode 函数"),i("code",[v._v("a.key === b.key")]),v._v("对比中可以避免就地复用的情况。所以会更加准确。")]),v._v(" "),i("li",[v._v("更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快")])])])}),[],!1,null,null,null);_.default=t.exports}}]);