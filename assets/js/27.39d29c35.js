(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{607:function(_,v,l){"use strict";l.r(v);var t=l(17),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("h2",{attrs:{id:"_1-输入url后发生了什么"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_1-输入url后发生了什么"}},[_._v("#")]),_._v(" 1. 输入url后发生了什么？")]),_._v(" "),l("ul",[l("li",[_._v("解析URL：分析传输协议和资源路径。")]),_._v(" "),l("li",[_._v("缓存判断：浏览器会判断请求资源是否在缓存里，若在且未失效，就直接用，反之向服务器发新请求。")]),_._v(" "),l("li",[_._v("DNS解析：本地是否有 IP 地址缓存，没有向本地 DNS 服务器发请求，没有先向根域名服务器——顶级域名——权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。"),l("strong",[_._v("DNS服务器是基于UDP的，因此会用到UDP协议。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。")])]),_._v(" "),l("li",[_._v("获取MAC地址：因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，"),l("strong",[_._v("数据链路层")]),_._v("需要。通过"),l("strong",[_._v("将 IP 地址与本机的子网掩码相与，判断是否与请求主机在同一个子网里")]),_._v("，同一个子网使用 APR 协议，不在一个子网里请求转发给网关，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。")]),_._v(" "),l("li",[_._v("建立TCP连接：根据IP地址和默认80、443端口，和服务器建立TCP连接\n"),l("ul",[l("li",[_._v("SYN 连接请求+一个随机序号sequence")]),_._v(" "),l("li",[_._v("SYN ACK报文段，确认连接请求，+随机序号sequence。")]),_._v(" "),l("li",[_._v("客户端接收确认应答后，进入连接建立的状态，发送ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。")])])]),_._v(" "),l("li",[_._v("HTTPS握手：如果使用的是 HTTPS 协议，在通信前还存在 "),l("strong",[_._v("TLS 的四次握手")]),_._v("过程。\n"),l("ul",[l("li",[_._v("首先由客户端向服务器端发送使用的"),l("strong",[_._v("协议的版本号、一个随机数和可以使用的加密方法")]),_._v("。")]),_._v(" "),l("li",[_._v("服务器端确认加密的方法，也向客户端发送"),l("strong",[_._v("随机数和自己的数字证书")]),_._v("。")]),_._v(" "),l("li",[_._v("客户端首先检查数字证书是否有效，如果有效，则再生成一个随机数，并"),l("strong",[_._v("使用证书中的公钥对随机数加密")]),_._v("，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。")]),_._v(" "),l("li",[_._v("服务器端"),l("strong",[_._v("使用私钥对数据解密")]),_._v("，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，"),l("strong",[_._v("使用这三个随机数生成一把秘钥")]),_._v("。后续进行对称加密。")])])]),_._v(" "),l("li",[_._v("返回数据：浏览器接收到响应后对 html 文件进行解析，开始页面的渲染过程。")]),_._v(" "),l("li",[_._v("关闭TCP连接：通过四次挥手释放TCP连接\n"),l("ul",[l("li",[_._v("客户端向服务端"),l("strong",[_._v("发送连接释放请求")]),_._v("。")]),_._v(" "),l("li",[_._v("服务端告诉应用层要释放 TCP 链接。"),l("strong",[_._v("发送 ACK 包进入 CLOSE_WAIT 状态")]),_._v("，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。")]),_._v(" "),l("li",[_._v("服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端"),l("strong",[_._v("发送连接释放")]),_._v("请求，然后"),l("strong",[_._v("进入 LAST-ACK 状态")]),_._v("。")]),_._v(" "),l("li",[_._v("客户端向服务端发送确认应答，TIME-WAIT 状态。该状态会持续 "),l("strong",[_._v("2MSL（最大段生存期")]),_._v("，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。")])])]),_._v(" "),l("li",[_._v("页面渲染：\n"),l("ul",[l("li",[_._v("构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象")]),_._v(" "),l("li",[_._v("构建CSS规则树：生成CSS规则树（CSS Rule Tree）")]),_._v(" "),l("li",[_._v("构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）——渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，"),l("strong",[_._v("不可见的 DOM 元素不会被插入渲染树")]),_._v("。")]),_._v(" "),l("li",[_._v("布局（Layout/reflow），负责各元素尺寸、位置的计算，也叫自动重排")]),_._v(" "),l("li",[_._v("绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。")]),_._v(" "),l("li",[l("ul",[l("li",[_._v("浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。\n"),l("img",{attrs:{src:"https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiNTRkMDY5ZWEtYTlmNi00ZGIwLTlmMzktYmU5ZjM4MzFjMzIwIiwicmVzb3VyY0d1aWQiOiJlODYxZmJlMC1lYzZkLTRhYzYtYTZhZS05YmE1NDBlYzgxM2MifQ==",alt:"image"}})])])])])]),_._v(" "),l("li",[_._v("JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）\n"),l("ul",[l("li",[_._v("创建window对象")]),_._v(" "),l("li",[_._v("加载文件")]),_._v(" "),l("li",[_._v("预编译")]),_._v(" "),l("li",[_._v("解释执行")])])])]),_._v(" "),l("h2",{attrs:{id:"_2-重绘与重排列区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_2-重绘与重排列区别"}},[_._v("#")]),_._v(" 2. 重绘与重排列区别")]),_._v(" "),l("p",[l("strong",[_._v("『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。")])]),_._v(" "),l("ul",[l("li",[_._v("重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。\n"),l("ul",[l("li",[_._v("添加、删除、更新DOM节点")]),_._v(" "),l("li",[_._v("通过display: none隐藏一个DOM节点-触发重排和重绘")]),_._v(" "),l("li",[_._v("移动或者给页面中的DOM节点添加动画")]),_._v(" "),l("li",[_._v("用户行为，例如调整窗口大小，改变字号，或者滚动。")]),_._v(" "),l("li",[_._v("添加一个样式表，调整样式属性")])])]),_._v(" "),l("li",[_._v("重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变\n"),l("ul",[l("li",[_._v("通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化")])])])]),_._v(" "),l("h2",{attrs:{id:"_3-渲染过程优化"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-渲染过程优化"}},[_._v("#")]),_._v(" 3. 渲染过程优化")]),_._v(" "),l("h3",{attrs:{id:"_3-1-针对js"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-针对js"}},[_._v("#")]),_._v(" 3.1 针对js")]),_._v(" "),l("p",[_._v("JS会阻塞渲染问题")]),_._v(" "),l("ul",[l("li",[_._v("尽量将js文件放在body的最后")]),_._v(" "),l("li",[l("code",[_._v("<script>")]),_._v("标签的引入资源尽量使用异步加载，不会阻塞DOM的解析，三者的区别如图\n"),l("ul",[l("li",[l("ul",[l("li",[l("strong",[_._v("async")]),_._v(" 是在下载完成之后，立即异步加载，加载好后立即执行，不保证顺序")])])]),_._v(" "),l("li",[l("strong",[_._v("defer")]),_._v(" 是在下载完成之后，立即异步加载。"),l("strong",[_._v("等 DOM 树解析好执行")]),_._v("。多个带defer按照"),l("strong",[_._v("顺序执行")]),_._v("。")])])])]),_._v(" "),l("h3",{attrs:{id:"_3-2-针对css"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-针对css"}},[_._v("#")]),_._v(" 3.2 针对css")]),_._v(" "),l("ul",[l("li",[l("strong",[_._v("link")]),_._v("：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码")]),_._v(" "),l("li",[l("strong",[_._v("@import")]),_._v("：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)")]),_._v(" "),l("li",[l("strong",[_._v("style")]),_._v("：GUI直接渲染")])]),_._v(" "),l("p",[_._v("导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。")]),_._v(" "),l("h3",{attrs:{id:"_3-3-针对dom树、cssom树"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-针对dom树、cssom树"}},[_._v("#")]),_._v(" 3.3 针对DOM树、CSSOM树")]),_._v(" "),l("ul",[l("li",[_._v("HTML文件的代码层级尽量不要太深——"),l("strong",[_._v("层级扁平化处理")])]),_._v(" "),l("li",[_._v("使用"),l("strong",[_._v("语义化的标签")]),_._v("，来避免不标准语义化的特殊处理")]),_._v(" "),l("li",[_._v("减少CSSD代码的层级，因为选择器是从左向右进行解析的")])]),_._v(" "),l("h3",{attrs:{id:"_3-4-减少回流与重绘"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-减少回流与重绘"}},[_._v("#")]),_._v(" 3.4 减少回流与重绘")]),_._v(" "),l("ul",[l("li",[_._v("集中改变样式，不要一条一条地修改 DOM 的样式。")]),_._v(" "),l("li",[_._v("不要把 DOM 结点的属性值放在循环里当成循环里的变量。")]),_._v(" "),l("li",[_._v("不要使用"),l("code",[_._v("table")]),_._v("布局， 一个小的改动可能会使整个"),l("code",[_._v("table")]),_._v("进行重新布局")]),_._v(" "),l("li",[_._v("使用CSS的表达式")]),_._v(" "),l("li",[_._v("不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。")]),_._v(" "),l("li",[_._v("动画的 HTML 元件使用absolute或者fixed，使元素脱离文档流，修改他们的 CSS 是不会 reflow 的；尽量只修改position：absolute或fixed元素，对其他元素影响不大")]),_._v(" "),l("li",[_._v("动画开始GPU加速，translate使用3D变化")]),_._v(" "),l("li",[_._v("避免频繁操作DOM，可以创建一个文档片段"),l("code",[_._v("documentFragment")]),_._v("，在它上面应用所有DOM操作，最后再把它添加到文档中")]),_._v(" "),l("li",[_._v("将元素先设置"),l("code",[_._v("display: none")]),_._v("，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。")]),_._v(" "),l("li",[_._v("将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于"),l("strong",[_._v("浏览器的渲染队列机制")]),_._v("。")]),_._v(" "),l("li",[_._v("提升为合成层\n"),l("ul",[l("li",[_._v("合成层的位图，会交由 GPU 合成，比 CPU 处理要快")]),_._v(" "),l("li",[_._v("当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层")]),_._v(" "),l("li",[_._v("对于 transform 和 opacity 效果，不会触发 layout 和 paint")])])])]),_._v(" "),l("p",[_._v("即浏览器针对页面的回流与重绘，进行了自身的优化——"),l("strong",[_._v("渲染队列")])]),_._v(" "),l("p",[l("strong",[_._v("浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。")])]),_._v(" "),l("h2",{attrs:{id:"_4-什么是文档的预解析"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_4-什么是文档的预解析"}},[_._v("#")]),_._v(" 4. 什么是文档的预解析？")]),_._v(" "),l("p",[_._v("当执行JS脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载速度更快。注意，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。")]),_._v(" "),l("h2",{attrs:{id:"_5-css-如何阻塞文档解析"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_5-css-如何阻塞文档解析"}},[_._v("#")]),_._v(" 5. CSS 如何阻塞文档解析？")]),_._v(" "),l("ul",[l("li",[_._v("css加载不会阻塞DOM树解析（异步加载时DOM照常构建）")]),_._v(" "),l("li",[_._v("但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）\n也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行JS，最后再继续文档的解析。")])]),_._v(" "),l("h2",{attrs:{id:"_6-什么情况会阻塞渲染"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_6-什么情况会阻塞渲染"}},[_._v("#")]),_._v(" 6. 什么情况会阻塞渲染？")]),_._v(" "),l("ul",[l("li",[_._v("渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小——有对应的loader对html、css文件压缩")]),_._v(" "),l("li",[_._v("并且扁平层级，优化选择器。")]),_._v(" "),l("li",[_._v("不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。（或defer、async）")])]),_._v(" "),l("h2",{attrs:{id:"_7-如何优化关键渲染路径"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何优化关键渲染路径"}},[_._v("#")]),_._v(" 7. 如何优化关键渲染路径？")]),_._v(" "),l("p",[_._v("为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：")]),_._v(" "),l("ul",[l("li",[_._v("关键资源的数量。")]),_._v(" "),l("li",[_._v("关键路径长度。——某些资源只能在上一资源处理完毕之后才能开始下载")]),_._v(" "),l("li",[_._v("关键字节的数量。")])]),_._v(" "),l("p",[_._v("优化关键渲染路径的常规步骤如下：")]),_._v(" "),l("ul",[l("li",[_._v("对关键路径进行分析和特性描述：资源数、字节数、长度。")]),_._v(" "),l("li",[_._v("最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。")]),_._v(" "),l("li",[_._v("优化关键字节数以缩短下载时间（往返次数）。")]),_._v(" "),l("li",[_._v("优化其余关键资源的加载顺序：需要尽早下载所有关键资产，以缩短关键路径长度")])])])}),[],!1,null,null,null);v.default=s.exports}}]);