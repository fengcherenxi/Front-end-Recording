(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{644:function(t,e,n){"use strict";n.r(e);var r=n(17),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"子组件可以直接改变父组件的数据吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#子组件可以直接改变父组件的数据吗"}},[t._v("#")]),t._v(" 子组件可以直接改变父组件的数据吗？")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。\n如果这样做了，Vue 会在浏览器的控制台中发出警告。")])]),t._v(" "),n("li",[n("p",[t._v("Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。\n这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。\n如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。")])]),t._v(" "),n("li",[n("p",[t._v("只能通过 "),n("strong",[t._v("$emit")]),t._v(" 派发一个自定义事件，父组件接收到后，由父组件修改。")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);