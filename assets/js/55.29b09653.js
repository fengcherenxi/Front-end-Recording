(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{648:function(t,s,e){"use strict";e.r(s);var a=e(17),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-双向数据绑定原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-双向数据绑定原理"}},[t._v("#")]),t._v(" 1. 双向数据绑定原理")]),t._v(" "),e("p",[t._v("Vue.js的两个核心就是 组件系统和 数据驱动（双向数据绑定）")]),t._v(" "),e("ul",[e("li",[t._v("数据驱动——当一个Vue实例创建时会遍历data中的属性，用 Object.defineProperty/proxy进行数据劫持，且在内部追踪相关依赖dev，在属性被访问和修改时通知变化。")]),t._v(" "),e("li",[t._v("组件系统——每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/16/16c986328e407929~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp",alt:""}})]),t._v(" "),e("p",[t._v("Vue.js 是采用"),e("strong",[t._v("数据劫持")]),t._v("结合"),e("strong",[t._v("发布者-订阅者模式")]),t._v("的方式，通过Object.defineProperty()来劫持各个属性，数据变动时发布消息给订阅者，触发相应的监听回调。步骤：")]),t._v(" "),e("ul",[e("li",[t._v("需要observe的数据对象进行递归遍历加上setter和getter。")]),t._v(" "),e("li",[t._v("compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),t._v(" "),e("li",[t._v("Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。")]),t._v(" "),e("li",[t._v("MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。")])]),t._v(" "),e("h2",{attrs:{id:"_2-vue-template-到-render-的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue-template-到-render-的过程"}},[t._v("#")]),t._v(" 2. Vue template 到 render 的过程")]),t._v(" "),e("p",[t._v("模版编译过程主要："),e("strong",[t._v("template -> ast -> render函数")]),t._v("。将template转化成JS函数，浏览器可执行这个函数并渲染出对应HTML。\n模板编译分三个阶段：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("解析阶段")]),t._v("：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等parse为抽象语法树AST。")]),t._v(" "),e("li",[e("strong",[t._v("优化阶段")]),t._v("：遍历AST，找到其中的一些静态节点进行标记，在页面重渲染的时候进行diff比较时跳过静态节点，优化runtime的性能。")]),t._v(" "),e("li",[e("strong",[t._v("生成阶段")]),t._v("：将AST转化为render函数字符串。")])]),t._v(" "),e("p",[t._v("vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将模板编译为render函数")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" render"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" staticRenderFns "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("compileToFunctions")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("template"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("options"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//省略}, this)")]),t._v("\n")])])]),e("p",[t._v("CompileToFunctions主要逻辑∶")]),t._v(" "),e("ul",[e("li",[t._v("调用parse方法将template=>ast（抽象语法树）")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ast "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("template"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("trim")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("ul",[e("li",[e("strong",[t._v("解析")]),t._v("：利用正则表达式顺序解析模板，当解析开始闭合标签、文本时都会执行对应回调，构造AST树。")]),t._v(" "),e("li",[t._v("AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本")])]),t._v(" "),e("ul",[e("li",[t._v("对静态节点做优化")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("optimize")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ast"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("options"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("分析静态节点打标记，为后续渲染可直接跳过静态节点做优化；深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。")]),t._v(" "),e("ul",[e("li",[t._v("生成代码")])]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" code "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("generate")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ast"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[t._v("将ast抽象语法树编译成render字符串并将静态部分放到 staticRenderFns 中，最后通过 "),e("code",[t._v("new Function(`` render``)")]),t._v(" 生成render函数。")])])}),[],!1,null,null,null);s.default=n.exports}}]);