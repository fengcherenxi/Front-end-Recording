(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{597:function(t,_,v){"use strict";v.r(_);var T=v(17),i=Object(T.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"http1-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http1-1"}},[t._v("#")]),t._v(" http1.1")]),t._v(" "),v("ul",[v("li",[t._v("长连接：1.0的问题，发请求都要新建TCP连接，串行请求，通信开销大。1.1长连接。减少了 TCP 连接的额外开销，减轻了服务器负载。")]),t._v(" "),v("li",[t._v("管道网络传输：即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是"),v("strong",[t._v("服务器还是按照顺序")]),t._v("。要是 前面的回应特别慢，后面就会有许多请求排队等着。队头堵塞问题。")])]),t._v(" "),v("p",[t._v("性能瓶颈：")]),t._v(" "),v("ul",[v("li",[t._v("头部未压缩，延迟大。只压缩 Body；发送冗长的首部、相同的首部；")]),t._v(" "),v("li",[t._v("按顺序响应，队头阻塞；")]),t._v(" "),v("li",[t._v("受限的优先级设置:HTTP/1.1 无法为重要的资源指定优先级。")]),t._v(" "),v("li",[t._v("服务器只能被动响应，不能推送消息。")]),t._v(" "),v("li",[t._v("低效的 TCP 利用 :TCP慢启动机制，导致每个 TCP 连接在一开始的时候传输速率都不高，在处理多个请求后，才会慢慢达到“合适”的速率。对于请求数据量很小的 HTTP 请求来说，这种情况就是种灾难。")]),t._v(" "),v("li",[t._v("臃肿的消息首部 :HTTP/1.1 的首部无法压缩，再加上 cookie 的存在，经常会出现首部大小比请求数据大小还大的情况。")])]),t._v(" "),v("h2",{attrs:{id:"http2-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http2-0"}},[t._v("#")]),t._v(" http2.0")]),t._v(" "),v("p",[t._v("HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。")]),t._v(" "),v("ul",[v("li",[t._v("多路复用：在 HTTP/1.1 中，如果客户端想发送多个并行的请求，那么必须使用多个 TCP 连接。 而 HTTP/2 的二进制分帧层突破了这一限制，所有的请求和响应都在同一个 TCP 连接上发送：客户端和服务器把 HTTP 消息分解成多个帧，然后乱序发送，最后在另一端再根据流 ID 重新组合起来。&& 可在一个连接中并发多个请求或回应，不用按照顺序一一对应。移除串行请求，不需要排队等待，不会出现「队头阻塞」，降低延迟。举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。")]),t._v(" "),v("li",[t._v("二进制帧格式，解析速度快")]),t._v(" "),v("li",[t._v("压缩头部")]),t._v(" "),v("li",[t._v("优先级：通过 HEADERS 帧和 PRIORITY 帧，客户端可以明确地和服务器沟通它需要什么，以及它需要这些资源的顺序。具体来讲，服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。")]),t._v(" "),v("li",[t._v("服务器推送")]),t._v(" "),v("li",[t._v("流量控制")]),t._v(" "),v("li",[t._v("在 HTTP/1.1 中要把多个小资源合并成一个大资源，从而减少请求。而在 HTTP/2 就不需要了，因为 HTTP/2 所有的请求都可以在一个 TCP 连接发送。")]),t._v(" "),v("li",[t._v("数据流")])]),t._v(" "),v("p",[t._v("缺陷：")]),t._v(" "),v("ul",[v("li",[t._v("HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了；HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。")])]),t._v(" "),v("h2",{attrs:{id:"http3-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http3-0"}},[t._v("#")]),t._v(" http3.0")]),t._v(" "),v("p",[t._v("基于 TCP 传输层的问题，所以改成UDP：UDP 发生是不管顺序、不管丢包，所以不会出现 1.1 的队头阻塞 和 2 的丢包重传问题。UDP 是不可靠传输的，但基于 UDP+QUIC 协议 可以实现类似 TCP 的可靠性传输。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZfXG1113Sjm0iaOXfoOv0tlUyP3HNicKS2J21mHQD9EepOiciakC8nRkrX9C3I0hjC6Fhjvd4nLiakuLeg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:""}})])])}),[],!1,null,null,null);_.default=i.exports}}]);