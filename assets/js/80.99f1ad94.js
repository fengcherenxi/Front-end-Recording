(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{661:function(t,a,s){"use strict";s.r(a);var r=s(17),n=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("《剑指Offer》")]),t._v(" "),s("h2",{attrs:{id:"面试题3-二维数组中查找"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题3-二维数组中查找"}},[t._v("#")]),t._v(" 面试题3：二维数组中查找")]),t._v(" "),s("p",[t._v("题目：从左到右从上倒下递增。给定一个整数x，判断数组中是否含有该数？")]),t._v(" "),s("p",[t._v("解法：选取右上角的数m，若m > x则删除该列，若m < x则删除改行。")]),t._v(" "),s("h2",{attrs:{id:"面试题4-替换空格"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题4-替换空格"}},[t._v("#")]),t._v(" 面试题4：替换空格")]),t._v(" "),s("p",[t._v("解法：从前往后遍历时间复杂度高O(n^2)，改进，先一次遍历计算空格数量，再从后向前遍历依次搬。")]),t._v(" "),s("p",[s("strong",[t._v("相关题目：")])]),t._v(" "),s("p",[t._v("两个排序数组A1和A2，将A2插入A1中——从尾到头比较；")]),t._v(" "),s("p",[t._v("合并两个数组（包括字符串）时，如果从前往后复制每个数字（或字符）需要重复移动数字（或字符）多次，可考虑从后往前复制，从而提高效率。")]),t._v(" "),s("h2",{attrs:{id:"面试题5-从尾到头打印链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题5-从尾到头打印链表"}},[t._v("#")]),t._v(" 面试题5：从尾到头打印链表")]),t._v(" "),s("p",[t._v("解法：栈/递归，但链表很长时递归会溢出")]),t._v(" "),s("h3",{attrs:{id:"链表高频题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表高频题"}},[t._v("#")]),t._v(" 链表高频题")]),t._v(" "),s("ul",[s("li",[t._v("面试题5“从尾到头输出链表”")]),t._v(" "),s("li",[t._v("面试题13“在O（1）时间删除链表结点”")]),t._v(" "),s("li",[t._v("面试题15“链表中的倒数第k个结点”")]),t._v(" "),s("li",[t._v("面试题16“反转链表”")]),t._v(" "),s("li",[t._v("面试题17“合并两个排序的链表”")]),t._v(" "),s("li",[t._v("面试题 37“两个链表的第一个公共结点”")]),t._v(" "),s("li",[t._v("把链表的末尾结点的指针指向头结点，从而形成一个环形链表（面试题45“圆圈中最后剩下的数字”）")]),t._v(" "),s("li",[t._v("链表中的结点中除了有指向下一个结点的指针，还有指向前一个结点的指针。这就是双向链表（面试题27“二叉搜索树与双向链表”）")]),t._v(" "),s("li",[t._v("链表中的结点中除了有指向下一个结点的指针，还有指向任意结点的指针，这就是复杂链表（面试题26“复杂链表的复制”）")])]),t._v(" "),s("h2",{attrs:{id:"面试题6-重建二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题6-重建二叉树"}},[t._v("#")]),t._v(" 面试题6：重建二叉树")]),t._v(" "),s("p",[t._v("题目：前序遍历+中序遍历——二叉树。")]),t._v(" "),s("p",[t._v("解法：前序遍历确定根节点，中序遍历确定左子树和右子树 + 递归")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("buildTree")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" inorder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("TreeNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("val")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("dfs")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("arr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" targetVal "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" preorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" newRoot "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("targetVal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" targetIndex "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("indexOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("targetVal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("targetIndex"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" leftArr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("targetIndex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                newRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("leftArr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" rightArr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("targetIndex"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                newRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("index"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("leftArr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("rightArr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" newRoot\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("dfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("inorder"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h3",{attrs:{id:"二叉树高频题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉树高频题"}},[t._v("#")]),t._v(" 二叉树高频题")]),t._v(" "),s("ul",[s("li",[t._v("面试题39“二叉树的深度”")]),t._v(" "),s("li",[t._v("面试题18“树的子结构”")]),t._v(" "),s("li",[t._v("面试题25“二叉树中和为某一值的路径”")]),t._v(" "),s("li",[t._v("面试题6“重建二叉树”")]),t._v(" "),s("li",[t._v("面试题24“二叉树的后序遍历序列”")]),t._v(" "),s("li",[t._v("面试题23“从上到下遍历二叉树”就是考查宽度优先遍历算法的题目")]),t._v(" "),s("li",[t._v("面试题50“树中两个结点的最低公共祖先”")]),t._v(" "),s("li",[t._v("面试题27“二叉搜索树与双向链表”")]),t._v(" "),s("li",[t._v("与堆和红黑树相关的面试题，请参考面试题30“求最小的k个数字”")])]),t._v(" "),s("h2",{attrs:{id:"面试题7-用两个栈实现队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题7-用两个栈实现队列"}},[t._v("#")]),t._v(" 面试题7：用两个栈实现队列")]),t._v(" "),s("p",[t._v("简单")]),t._v(" "),s("h2",{attrs:{id:"面试题8-旋转数组的最小数字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题8-旋转数组的最小数字"}},[t._v("#")]),t._v(" 面试题8：旋转数组的最小数字")]),t._v(" "),s("p",[t._v("题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。")]),t._v(" "),s("p",[t._v("解法：数组一定程度上是排序的，试用二分查找法。")]),t._v(" "),s("p",[t._v("注意特例：")]),t._v(" "),s("ul",[s("li",[t._v("如果把排序数组的前面的 0 个元素搬到最后面，即排序数组本身，这仍然是数组的一个旋转，我们的代码需要支持这种情况。一旦发现数组中第一个数字小于最后一个数字，表明该数组是排序的，就可以直接返回第一个数字了。")]),t._v(" "),s("li",[t._v("当两个指针指向的数字及它们中间的数字三者相同的时候，我们无法判断中间的数字是位于前面的子数组中还是后面的子数组中，也就无法移动两个指针来缩小查找的范围。此时，我们不得不采用顺序查找的方法。")])]),t._v(" "),s("h3",{attrs:{id:"查找排序总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查找排序总结"}},[t._v("#")]),t._v(" 查找排序总结")]),t._v(" "),s("ul",[s("li",[t._v("面试题8“旋转数组的最小数字”")]),t._v(" "),s("li",[t._v("面试题 38“数字在排序数组中出现的次数”都可以用二分查找算法解决。")]),t._v(" "),s("li",[t._v("如果面试题是要求在排序数组中查找一个数字或者统计某个数字出现的次数，可用二分查找算法。")]),t._v(" "),s("li",[t._v("面试题35“第一个只出现一次的字符”就是用"),s("strong",[t._v("哈希表的特性来高效查找")]),t._v("。")]),t._v(" "),s("li",[s("strong",[t._v("快速排序算法")]),t._v("的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组的左边，比选择的数字大的数字移到数组的右边。可以递归实现快速排序。\n"),s("ul",[s("li",[t._v("函数 Partition 除了可以用在快速排序算法中，还可以用来实现在长度为n的数组中查找第k大的数字。")]),t._v(" "),s("li",[t._v("面试题29“数组中出现次数超过一半的数字”和面试题30“最小的k个数”都可以用这个函数来解决。")]),t._v(" "),s("li",[t._v("快速排序虽然总体的平均效率是最好的，但也不是任何时候都是最优的算法。比如数组本身已经排好序了，而每一轮排序的时候都是以最后一个数字作为比较的标准，此时快速排序的效率只有O（n2）")])])])]),t._v(" "),s("h2",{attrs:{id:"面试题9-斐波那契数列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题9-斐波那契数列"}},[t._v("#")]),t._v(" 面试题9：斐波那契数列")]),t._v(" "),s("p",[t._v("解法1:递归")]),t._v(" "),s("p",[t._v("解法1:循环")]),t._v(" "),s("p",[t._v("时间复杂度O（logn）但不够实用的解法：数学公式——面试题11“数值的整数次方”中再详细讨论这种算法。")]),t._v(" "),s("h3",{attrs:{id:"递归循环题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#递归循环题"}},[t._v("#")]),t._v(" 递归循环题")]),t._v(" "),s("ul",[s("li",[t._v("面试题 9“斐波那契数列”")]),t._v(" "),s("li",[t._v("面试题43“n个骰子的点数”")]),t._v(" "),s("li",[t._v("爬楼梯——斐波那契数列")]),t._v(" "),s("li",[t._v("在青蛙跳台阶的问题中，如果把条件改成：一只青蛙一次可以跳上 1级台阶，也可以跳上 2 级……它也可以跳上 n 级，此时该青蛙跳上一个 n级的台阶总共有多少种跳法？我们用数学归纳法可以证明f（n）=2n-1。")]),t._v(" "),s("li",[t._v("我们可以用 2×1（图2.13 的左边）的小矩形横着或者竖着去覆盖更大的矩形。请问用8个2×1的小矩形无重叠地覆盖一个2×8的大矩形（图2.13的右边），总共有多少种方法？——斐波那契数列")])]),t._v(" "),s("h2",{attrs:{id:"面试题10-二进制中1的个数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题10-二进制中1的个数"}},[t._v("#")]),t._v(" 面试题10：二进制中1的个数")]),t._v(" "),s("p",[t._v("n = (n-1) & n，计算1的个数次。右移注意：有符号数值用数字的符号位填补最左边的n位。负数右移后补n个1。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("hamWeight")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" res "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        res"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" res\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"位运算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#位运算"}},[t._v("#")]),t._v(" 位运算")]),t._v(" "),s("ul",[s("li",[t._v("面试题 40“数组中只出现一次的数字”——异或")]),t._v(" "),s("li",[t._v("面试题 47“不用加减乘除做加法”")]),t._v(" "),s("li",[t._v("用一条语句判断一个整数是不是2的整数次方。一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是0。根据前面的分析，把这个整数减去1之后再和它自己做与运算，这个整数中唯一的1就会变成0。")]),t._v(" "),s("li",[t._v("输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。比如 10 的二进制表示为 1010，13 的二进制表示为1101，需要改变1010中的3位才能得到1101。我们可以分为两步解决这个问题：第一步求这两个数的异或，第二步统计异或结果中1的位数。")])]),t._v(" "),s("h2",{attrs:{id:"面试题11-数值的整数次方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题11-数值的整数次方"}},[t._v("#")]),t._v(" 面试题11：数值的整数次方")]),t._v(" "),s("p",[t._v("解法2:递归")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("mayPow")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("x\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" res "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("myPow")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    res"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*=")]),t._v("res\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("res"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*=")]),t._v("x\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" res\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("位运算比乘除法高效的多：")]),t._v(" "),s("ul",[s("li",[t._v("用右移运算符代替了除以2")]),t._v(" "),s("li",[t._v("用位与运算符代替了求余运算符（%）来判断一个数是奇数还是偶数。")])]),t._v(" "),s("h2",{attrs:{id:"面试题12-打印1到最大的n位数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题12-打印1到最大的n位数"}},[t._v("#")]),t._v(" 面试题12：打印1到最大的n位数")]),t._v(" "),s("ul",[s("li",[t._v("坑：考虑大数问题——用字符串或者数组表达大数")]),t._v(" "),s("li",[t._v("JS解题：DFS递归+回溯")])]),t._v(" "),s("h2",{attrs:{id:"面试题13-在o-1-时间删除链表结点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题13-在o-1-时间删除链表结点"}},[t._v("#")]),t._v(" 面试题13：在O（1）时间删除链表结点")]),t._v(" "),s("p",[t._v("leetcode237 变形题")]),t._v(" "),s("ul",[s("li",[t._v("坑：O（1）时间需考虑所删除的结点是不是尾结点")]),t._v(" "),s("li",[t._v("把下一个结点的内容复制到需要删除的结点上覆盖原有的内容，再把下一个结点删除，那是不是就相当于把当前需要删除的结点删除了？")]),t._v(" "),s("li",[t._v("注意1：如果要删除的结点位于链表的尾部，那么它就没有下一个结点，怎么办？我们仍然从链表的头结点开始，顺序遍历得到该结点的前序结点，并完成删除操作。")]),t._v(" "),s("li",[t._v("注意2：最后需要注意的是，如果链表中只有一个结点，而我们又要删除链表的头结点（也是尾结点），此时我们在删除结点之后，还需要把链表的头结点设置为NULL。")])]),t._v(" "),s("h2",{attrs:{id:"面试题14-调整数组顺序使奇数位于偶数前面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题14-调整数组顺序使奇数位于偶数前面"}},[t._v("#")]),t._v(" 面试题14：调整数组顺序使奇数位于偶数前面")]),t._v(" "),s("ul",[s("li",[t._v("双指针")]),t._v(" "),s("li",[t._v("进阶：可以把交换判断标准解藕成一个函数")])]),t._v(" "),s("h2",{attrs:{id:"面试题15-链表中倒数第k个结点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题15-链表中倒数第k个结点"}},[t._v("#")]),t._v(" 面试题15：链表中倒数第k个结点")]),t._v(" "),s("ul",[s("li",[t._v("快慢指针")]),t._v(" "),s("li",[t._v("坑：\n"),s("ul",[s("li",[t._v("注意1:k=0")]),t._v(" "),s("li",[t._v("注意2:head为空")]),t._v(" "),s("li",[t._v("注意3:k>链表的长度")])])])]),t._v(" "),s("p",[t._v("鲁棒性问题：面试题15“链表中倒数第k个结点”，这里隐含着一个条件就是链表中结点的个数大于k")]),t._v(" "),s("p",[s("strong",[t._v("相关题目：")])]),t._v(" "),s("ul",[s("li",[t._v("求链表的中间结点。如果链表中结点总数为奇数，返回中间结点；如果结点总数是偶数，返回中间两个结点的任意一个。快慢（二倍速）指针")]),t._v(" "),s("li",[t._v("环形结构——快慢（二倍速）指针")])]),t._v(" "),s("h2",{attrs:{id:"面试题16-反转链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题16-反转链表"}},[t._v("#")]),t._v(" 面试题16：反转链表")]),t._v(" "),s("p",[t._v("三指针迭代")]),t._v(" "),s("p",[t._v("注意头结点为空或链表为单的情况")]),t._v(" "),s("p",[t._v("用递归实现同样的反转链表的功能。")]),t._v(" "),s("h2",{attrs:{id:"面试题17-合并两个排序的链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题17-合并两个排序的链表"}},[t._v("#")]),t._v(" 面试题17：合并两个排序的链表")]),t._v(" "),s("p",[t._v("注意两个链表为空的情况")]),t._v(" "),s("h2",{attrs:{id:"面试题18-树的子结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题18-树的子结构"}},[t._v("#")]),t._v(" 面试题18：树的子结构")]),t._v(" "),s("p",[t._v("两层递归：")]),t._v(" "),s("ul",[s("li",[t._v("递归寻找相同的结点（根节点）")]),t._v(" "),s("li",[t._v("从根结点递归判断各自左右子结点是否相等")])]),t._v(" "),s("h2",{attrs:{id:"面试题19-二叉树的镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题19-二叉树的镜像"}},[t._v("#")]),t._v(" 面试题19：二叉树的镜像")]),t._v(" "),s("p",[t._v("递归：先前序遍历这棵树的每个结点，如果遍历到的结点有子结点，就交换它的两个子结点。当交换完所有非叶子结点的左右子结点之后，就得到了树的镜像。")]),t._v(" "),s("p",[t._v("用循环：考虑BFS")]),t._v(" "),s("h2",{attrs:{id:"面试题20-顺时针打印矩阵"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题20-顺时针打印矩阵"}},[t._v("#")]),t._v(" 面试题20：顺时针打印矩阵")]),t._v(" "),s("p",[t._v("技巧：从外到里其实每次都遍历一个圆圈")]),t._v(" "),s("p",[t._v("难点：每一圈四个方向的遍历的起始和终点，以及开始条件")]),t._v(" "),s("h2",{attrs:{id:"面试题21-包含min函数的栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题21-包含min函数的栈"}},[t._v("#")]),t._v(" 面试题21：包含min函数的栈")]),t._v(" "),s("p",[t._v("建立m_Min辅助栈：存每一个push元素时对应的min值")]),t._v(" "),s("h2",{attrs:{id:"面试题22-栈的压入、弹出序列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题22-栈的压入、弹出序列"}},[t._v("#")]),t._v(" 面试题22：栈的压入、弹出序列")]),t._v(" "),s("p",[t._v("判决调节：建立辅助栈，若popped[0]===stc[-1],则同时弹出，否则push元素；设置flag")]),t._v(" "),s("p",[t._v("判断popped和pushed是否都为空，都为空反转flag为true")]),t._v(" "),s("h2",{attrs:{id:"面试题23-从上往下打印二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题23-从上往下打印二叉树"}},[t._v("#")]),t._v(" 面试题23：从上往下打印二叉树")]),t._v(" "),s("p",[t._v("层序遍历：初始化两个空数组，分别作为队列和输出数组")]),t._v(" "),s("p",[t._v("注意：⚠️root为空的情况，不能试图访问一个指针")]),t._v(" "),s("h2",{attrs:{id:"面试题24-二叉搜索树的后序遍历"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题24-二叉搜索树的后序遍历"}},[t._v("#")]),t._v(" 面试题24：二叉搜索树的后序遍历")]),t._v(" "),s("p",[t._v("题目：给定数组，判断是不是二叉搜索树的后序遍历结果")]),t._v(" "),s("p",[t._v("实际写代码的时候有难度")]),t._v(" "),s("p",[t._v("技巧：")]),t._v(" "),s("ul",[s("li",[t._v("后序遍历最后一个结点是根节点：设置根节点root = nums[-1]")]),t._v(" "),s("li",[t._v("遍历列表找到第一个比根节点大的元素，得到左子树列表，剩下的假设为右子树列表：找到对应的标记i")]),t._v(" "),s("li",[t._v("如果右子树列表中存在小于根结点的值，则返回false：初始化left，right=true，leftNums，rightNums")]),t._v(" "),s("li",[t._v("递归，若不存在false情况则返回true:\n"),s("ul",[s("li",[t._v("当 i > 0 左递归")]),t._v(" "),s("li",[t._v("当 i < length-1 右递归")]),t._v(" "),s("li",[t._v("return left && right")])])])]),t._v(" "),s("h2",{attrs:{id:"面试题25-二叉树中和为某一值的路径"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题25-二叉树中和为某一值的路径"}},[t._v("#")]),t._v(" 面试题25：二叉树中和为某一值的路径")]),t._v(" "),s("p",[t._v("这道题一定要注意记录path使用深拷贝（newPath = path.slice(0）")]),t._v(" "),s("p",[t._v("技巧：")]),t._v(" "),s("ul",[s("li",[t._v("只有前序遍历是先访问根节点，使用前序遍历跟新纪录path")]),t._v(" "),s("li",[t._v("遍历结点，添加结点值到path中，target-=cur.val")]),t._v(" "),s("li",[t._v("若isLeaf且target===0：深拷贝path到res中，否则进行递归")]),t._v(" "),s("li",[t._v("递归前记得回溯，即target+=cur.val，并path.pop()")])]),t._v(" "),s("h2",{attrs:{id:"面试题26-复杂链表的复制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题26-复杂链表的复制"}},[t._v("#")]),t._v(" 面试题26：复杂链表的复制")]),t._v(" "),s("p",[t._v("三步：")]),t._v(" "),s("ul",[s("li",[t._v("复制结点")]),t._v(" "),s("li",[t._v("连接复制结点的random线")]),t._v(" "),s("li",[t._v("拆分原链表和复制链表，返回复制链表")])]),t._v(" "),s("h2",{attrs:{id:"面试题27-二叉搜索树和双向链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题27-二叉搜索树和双向链表"}},[t._v("#")]),t._v(" 面试题27：二叉搜索树和双向链表")]),t._v(" "),s("p",[t._v("要求转换后的双向链表是排好序的：中序遍历二叉搜索树得到的是排序的结果")]),t._v(" "),s("p",[t._v("技巧：")]),t._v(" "),s("ul",[s("li",[t._v("定义dfs：\n"),s("ul",[s("li",[t._v("dfs(cur.left)")]),t._v(" "),s("li",[t._v("逻辑：纠正pre和cur的连接，并设置head结点，移动pre")]),t._v(" "),s("li",[t._v("dfs(cur.right)")])])]),t._v(" "),s("li",[t._v("dfs(root)后，连接尾结点和头结点，返回头结点")])]),t._v(" "),s("h2",{attrs:{id:"面试题28-字符串的排列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题28-字符串的排列"}},[t._v("#")]),t._v(" 面试题28：字符串的排列")]),t._v(" "),s("p",[t._v("把字符串看成两部分：第一个字符和后面的所有字符")]),t._v(" "),s("p",[t._v("求排列看成两步：")]),t._v(" "),s("ul",[s("li",[t._v("求所有可能出现在第一个位置的字符，即把第一个字符和后面所有字符交换")]),t._v(" "),s("li",[t._v("固定第一个字符后求后面所有字符的排列")]),t._v(" "),s("li",[t._v("仍把后面的字符分成两部分：递归")])]),t._v(" "),s("p",[t._v("扩展：求字符的排列——改为求字符的组合")]),t._v(" "),s("ul",[s("li",[t._v("分别求n-1字符串中长度为m-1的组合")]),t._v(" "),s("li",[t._v("求n-1个字符的长度为m的组合。")]),t._v(" "),s("li",[t._v("两个子问题都用递归的思路")])]),t._v(" "),s("p",[t._v("若面试题是按照一定要求摆放若干数字，先求出这些数字的所有排列，然后再一一判断排列是不是满足题目给定的要求")]),t._v(" "),s("h2",{attrs:{id:"面试题29-数组中出现次数超过一半的数字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题29-数组中出现次数超过一半的数字"}},[t._v("#")]),t._v(" 面试题29:数组中出现次数超过一半的数字")]),t._v(" "),s("p",[t._v("优化方向：从O(nlogn)优化到O(n)")]),t._v(" "),s("ul",[s("li",[t._v("出现了一半以上，若排序数组则一定出现在中间")]),t._v(" "),s("li",[t._v("有成熟的方法O(n)得到数组中任意第k大的数字")]),t._v(" "),s("li",[t._v("方法1:Partition（基于快排）找任意第k大（直到该数字的下标是n/2）——缺点：改变了原数组")]),t._v(" "),s("li",[t._v("方法2:由于出现的次数最多，遍历数组保存两个值（数组中的数字，次数），若遍历的数字和之前保存的数字相同次数+1，不同-1，为0则保存当前数字，最后剩余的数字一定就是出现最多的。——不用修改数组")])]),t._v(" "),s("h2",{attrs:{id:"面试题30-最小的k个数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题30-最小的k个数"}},[t._v("#")]),t._v(" 面试题30:最小的k个数")]),t._v(" "),s("ul",[s("li",[t._v("方法1:Partition（基于快排）找任意第k大——缺点：改变了原数组")]),t._v(" "),s("li",[t._v("方法2:O(nlogk)的算法，适合处理海量数据：\n"),s("ul",[s("li",[t._v("大小为k的容器存储前k个数字（大顶堆）")]),t._v(" "),s("li",[t._v("依次遍历，若小于k中最大的数字，则插入，否则继续遍历")]),t._v(" "),s("li",[t._v("删除最大值，插入当前值O(logk)，n个故O(nlogk)")]),t._v(" "),s("li",[t._v("还可以考虑红黑树")])])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将第target个元素进行下沉")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("adjust")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" target "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//i对应位左子节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 找到孩子节点中最大的")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" len "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//对比右子节点")]),t._v("\n            i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下沉")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n            target "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构建大顶堆，从第一个非叶子节点开始，进行下沉操作")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("creatHeap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" len "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" start "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parseInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("len "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// start及之前的就是非叶子节点")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" start"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("adjust")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" len"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 实现堆排序")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function heapSort(array) {")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     creatHeap(array);")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     // console.log(array);")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     // 交换第一个和最后一个元素，然后重新调整大顶堆")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     for (let i = array.length - 1; i > 0; i--) {")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//         [array[i], array[0]] = [array[0], array[i]];")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//         adjust(array, 0, i);")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     }")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     return array;")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// }")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 海量数据场景使用大顶堆对k个数据进行暂时缓存")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("getLeastNumbers")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" k")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" arrK "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("slice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("creatHeap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arrK"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("arrK"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            arrK"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("adjust")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arrK"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" k"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" arrK\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"面试题31-连续子数组的最大和"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题31-连续子数组的最大和"}},[t._v("#")]),t._v(" 面试题31:连续子数组的最大和")]),t._v(" "),s("p",[t._v("动态规划：当前遍历值为正数，max[i] = nums[i]+max[i-1]")]),t._v(" "),s("h2",{attrs:{id:"面试题32-从1到n整数中1出现的次数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题32-从1到n整数中1出现的次数"}},[t._v("#")]),t._v(" 面试题32:从1到n整数中1出现的次数")]),t._v(" "),s("p",[t._v("从数字规律出发（有点偏。。。）")]),t._v(" "),s("p",[t._v("基础解法：")]),t._v(" "),s("ul",[s("li",[t._v("累加1-n中1出现的次数")]),t._v(" "),s("li",[t._v("对10取余判断是不是1")])]),t._v(" "),s("h2",{attrs:{id:"面试题33-把数组排成最小的数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题33-把数组排成最小的数"}},[t._v("#")]),t._v(" 面试题33:把数组排成最小的数")]),t._v(" "),s("ul",[s("li",[t._v("写一个比较器函数compare：比较两个数谁派在前面更小")]),t._v(" "),s("li",[t._v("调用sort(compare)")])]),t._v(" "),s("h2",{attrs:{id:"面试题34-丑叔"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题34-丑叔"}},[t._v("#")]),t._v(" 面试题34:丑叔")]),t._v(" "),s("p",[t._v("丑数定义：只包含2、3、5的因子")]),t._v(" "),s("h2",{attrs:{id:"面试题35-第一个只出现一次的字符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题35-第一个只出现一次的字符"}},[t._v("#")]),t._v(" 面试题35:第一个只出现一次的字符")]),t._v(" "),s("p",[t._v("哈希表（字符的话考虑256长度的数组，字符是8bit类型）+两次遍历")]),t._v(" "),s("h2",{attrs:{id:"面试题36-数组中的逆序对"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题36-数组中的逆序对"}},[t._v("#")]),t._v(" 面试题36：数组中的逆序对")]),t._v(" "),s("p",[t._v("逆序对：前一个数字大于后一个数字")]),t._v(" "),s("ul",[s("li",[t._v("把数组分隔成子数组，统计出子数组的逆序对，排序")]),t._v(" "),s("li",[t._v("合并，统计合并后数组中的逆序对，排序")]),t._v(" "),s("li",[t._v("归并排序")]),t._v(" "),s("li",[t._v("O(nlogn)，相当于用O(n)空间置换时间")])]),t._v(" "),s("h2",{attrs:{id:"面试题37-两个链表的第一个公共结点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题37-两个链表的第一个公共结点"}},[t._v("#")]),t._v(" 面试题37:两个链表的第一个公共结点")]),t._v(" "),s("p",[t._v("遍历连个链表长度求差+快慢指针")]),t._v(" "),s("h2",{attrs:{id:"面试题38-数字在排序数组中出现次数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题38-数字在排序数组中出现次数"}},[t._v("#")]),t._v(" 面试题38:数字在排序数组中出现次数")]),t._v(" "),s("p",[t._v("排序——二分查找：查找数字的左右边界")]),t._v(" "),s("h2",{attrs:{id:"面试题39-二叉树的深度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题39-二叉树的深度"}},[t._v("#")]),t._v(" 面试题39:二叉树的深度")]),t._v(" "),s("ul",[s("li",[t._v("树的深度=左右子树深度较大值+1")]),t._v(" "),s("li",[t._v("递归")])]),t._v(" "),s("p",[t._v("扩展：判断树是不是平衡二叉树（任意左右子树深度差不超过1）")]),t._v(" "),s("ul",[s("li",[t._v("后序遍历，遍历到每一个结点之前已经遍历了左右子树")]),t._v(" "),s("li",[t._v("边遍历边记录深度")])]),t._v(" "),s("h2",{attrs:{id:"面试题40-数组中只出现一次的数字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题40-数组中只出现一次的数字"}},[t._v("#")]),t._v(" 面试题40:数组中只出现一次的数字")]),t._v(" "),s("p",[t._v("异或")]),t._v(" "),s("h2",{attrs:{id:"面试题41-和为s的两个数字vs和为s的连续正数序列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题41-和为s的两个数字vs和为s的连续正数序列"}},[t._v("#")]),t._v(" 面试题41：和为s的两个数字VS和为s的连续正数序列")]),t._v(" "),s("p",[t._v("题目一：两数之和为s")]),t._v(" "),s("ul",[s("li",[t._v("排序+双指针")])]),t._v(" "),s("p",[t._v("题目二：打印出和为s的连续正数序列（数组排好序了）")]),t._v(" "),s("ul",[s("li",[t._v("滑动窗口")])]),t._v(" "),s("h2",{attrs:{id:"面试题42-翻转单词vs左旋转字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题42-翻转单词vs左旋转字符串"}},[t._v("#")]),t._v(" 面试题42：翻转单词VS左旋转字符串")]),t._v(" "),s("p",[t._v("题目一：翻转单词（翻转每一个单词，不是整体翻转）")]),t._v(" "),s("ul",[s("li",[t._v("翻转一个单词的函数：头尾双指针交换对应字符")]),t._v(" "),s("li",[t._v("翻转整个句子")]),t._v(" "),s("li",[t._v("翻转每一个单词")])]),t._v(" "),s("p",[t._v("题目二：字符串左旋")]),t._v(" "),s("ul",[s("li",[t._v("先翻转两个部分")]),t._v(" "),s("li",[t._v("再翻转整体")])]),t._v(" "),s("h2",{attrs:{id:"面试题43-n个骰子的点数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题43-n个骰子的点数"}},[t._v("#")]),t._v(" 面试题43:n个骰子的点数")]),t._v(" "),s("p",[t._v("基于循环求解：")]),t._v(" "),s("ul",[s("li",[t._v("动态规划（有点偏。。。）")])]),t._v(" "),s("h2",{attrs:{id:"面试题44-扑克牌的顺子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题44-扑克牌的顺子"}},[t._v("#")]),t._v(" 面试题44:扑克牌的顺子")]),t._v(" "),s("ul",[s("li",[t._v("数组排序（任意牌当为0）")]),t._v(" "),s("li",[t._v("统计数组中0的个数")]),t._v(" "),s("li",[t._v("统计数组相邻数字之间的空缺数")]),t._v(" "),s("li",[t._v("看能否满足顺子")])]),t._v(" "),s("h2",{attrs:{id:"面试题45-圆圈中最后剩下的数字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题45-圆圈中最后剩下的数字"}},[t._v("#")]),t._v(" 面试题45:圆圈中最后剩下的数字")]),t._v(" "),s("p",[t._v("著名的约瑟夫环问题")]),t._v(" "),s("ul",[s("li",[t._v("方法1:环形链表模拟")]),t._v(" "),s("li",[t._v("方法2:分析每次被删除的数字的规律直接计算出圆圈中剩下的数字——比较数学")])]),t._v(" "),s("h2",{attrs:{id:"面试题46-求1-2-。。。n"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题46-求1-2-。。。n"}},[t._v("#")]),t._v(" 面试题46:求1+2+。。。n")]),t._v(" "),s("p",[t._v("要求：不能用while、for、if等关键字及条件判断语句")]),t._v(" "),s("p",[t._v("利用虚函数（针对c++选手）")]),t._v(" "),s("h2",{attrs:{id:"面试题47-不用加减乘除做加法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题47-不用加减乘除做加法"}},[t._v("#")]),t._v(" 面试题47:不用加减乘除做加法")]),t._v(" "),s("p",[t._v("二进制和——位运算")]),t._v(" "),s("h2",{attrs:{id:"面试题48-不能被继承的类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题48-不能被继承的类"}},[t._v("#")]),t._v(" 面试题48:不能被继承的类")]),t._v(" "),s("p",[t._v("利用c++设计一个不能被继承的类")]),t._v(" "),s("h2",{attrs:{id:"面试题49-把字符串转换成整数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题49-把字符串转换成整数"}},[t._v("#")]),t._v(" 面试题49:把字符串转换成整数")]),t._v(" "),s("p",[t._v("溢出等边界条件的考虑")]),t._v(" "),s("h2",{attrs:{id:"面试题50-树中两个结点的最低公共祖先-正面案例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题50-树中两个结点的最低公共祖先-正面案例"}},[t._v("#")]),t._v(" 面试题50:树中两个结点的最低公共祖先（正面案例）")]),t._v(" "),s("p",[t._v("是不是二叉树？")]),t._v(" "),s("ul",[s("li",[t._v("二叉搜索树：从根结点开始和两个输入数字做比较")])]),t._v(" "),s("p",[t._v("不是二叉搜索树，甚至不是二叉树，只是普通树？")]),t._v(" "),s("p",[t._v("问：有没有指向父结点的指针？")]),t._v(" "),s("ul",[s("li",[t._v("题目转换为求两个链表的第一个公共结点")])]),t._v(" "),s("p",[t._v("加难度：🈚指向父结点的指针")]),t._v(" "),s("ul",[s("li",[t._v("从根结点遍历树+回溯")])]),t._v(" "),s("p",[t._v("《剑指Offer（专项突破版）》")]),t._v(" "),s("h2",{attrs:{id:"整数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整数"}},[t._v("#")]),t._v(" 整数")]),t._v(" "),s("h3",{attrs:{id:"面试题1-整数除法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题1-整数除法"}},[t._v("#")]),t._v(" 面试题1：整数除法")]),t._v(" "),s("p",[t._v("直观解法是基于减法：但时间复杂度高")]),t._v(" "),s("p",[t._v("若被除数最多大于除数的2k倍，那么将被除数减去除数的2k倍，然后将剩余的被除数重复前面的步骤。优化后的时间复杂度是O（logn）。")]),t._v(" "),s("p",[t._v("如果有负数则可以将它们先转换成正数，计算正数的除法之后再根据需要调整商的正负号。")]),t._v(" "),s("p",[t._v("对于32位的整数而言，最小的整数是-231，最大的整数是231-1。因此，如果将-231转换为正数则会导致溢出。由于将任意正数转换为负数都不会溢出，因此可以先将正数都转换成负数，用前面优化之后的减法计算两个负数的除法，然后根据需要调整商的正负号。")]),t._v(" "),s("p",[t._v("int型整数的除法只有一种情况会导致溢出，即（-231）/（-1）。这是因为最大的正数为231-1，231超出了正数的范围。")]),t._v(" "),s("h3",{attrs:{id:"面试题2-二进制加法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题2-二进制加法"}},[t._v("#")]),t._v(" 面试题2：二进制加法")]),t._v(" "),s("p",[t._v("当二进制字符串比较长时，它表示的整数可能会超出int型整数或long型整数的范围，此时不能直接将其转换成整数。")]),t._v(" "),s("p",[t._v("从字符串的右端出发向左做加法。与十进制不同的是，二进制是逢二进一，当两个数位加起来等于2时就会产生进位")]),t._v(" "),s("h3",{attrs:{id:"面试题3-前n个数字二进制形式中1的个数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题3-前n个数字二进制形式中1的个数"}},[t._v("#")]),t._v(" 面试题3：前n个数字二进制形式中1的个数")]),t._v(" "),s("p",[t._v("思路一：")]),t._v(" "),s("ul",[s("li",[t._v("其中一种比较高效的方法是每次用“i&（i-1）”将整数i的最右边的1变成0。")]),t._v(" "),s("li",[t._v("上述代码的时间复杂度是O（nk）。")])]),t._v(" "),s("p",[t._v("思路二：")]),t._v(" "),s("ul",[s("li",[t._v("整数i的二进制形式中1的个数比“i&（i-1）”的二进制形式中1的个数多1。我们可以利用这个规律写出——动态规划的思想")]),t._v(" "),s("li",[t._v("不管整数i的二进制形式中有多少个1，上述代码只根据O（1）的时间就能得出整数i的二进制形式中1的数目，因此时间复杂度是O（n）。")])]),t._v(" "),s("p",[t._v("思路三：")]),t._v(" "),s("ul",[s("li",[t._v("偶数i和“i/2”的二进制形式中1的个数是相同的")]),t._v(" "),s("li",[t._v("奇数i的二进制形式中1的个数比“i/2”的1的个数多1")]),t._v(" "),s("li",[t._v("用“i>>1”计算“i/2”，用“i&1”计算“i%2”，这是因为位运算比除法运算和求余运算更高效。这种解法的时间复杂度也是O（n）")])]),t._v(" "),s("h3",{attrs:{id:"面试题4-只出现一次的数字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题4-只出现一次的数字"}},[t._v("#")]),t._v(" 面试题4：只出现一次的数字")]),t._v(" "),s("p",[t._v("其他数字都出现了三次（倍数关系）")]),t._v(" "),s("p",[t._v("出现了3次的数字的任意第i个数位之和都能被3整除。")]),t._v(" "),s("p",[t._v("若数组中所有数字的第i个数位相加之和能被3整除，那么只出现一次的数字的第i个数位一定是0；")]),t._v(" "),s("p",[t._v("若数组中所有数字的第i个数位相加之和被3除余1，那么只出现一次的数字的第i个数位一定是1。")]),t._v(" "),s("p",[t._v("代码“（num>>（31-i））&1”用来得到整数num的二进制形式中从左数起第i个数位。")]),t._v(" "),s("p",[t._v("举一反三：")]),t._v(" "),s("ul",[s("li",[t._v("题目：数组中只有一个数字出现m次，其他数字都出现n次。请找出那个唯一出现m次的数字。假设m不能被n整除。")]),t._v(" "),s("li",[t._v("分析：解决面试题4的方法可以用来解决同类型的问题。如果数组中所有数字的第i个数位相加之和能被n整除，那么出现m次的数字的第i个数位一定是0；否则出现m次的数字的第i个数位一定是1。")])]),t._v(" "),s("h3",{attrs:{id:"面试题5-单词长度的最大乘积"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题5-单词长度的最大乘积"}},[t._v("#")]),t._v(" 面试题5：单词长度的最大乘积")]),t._v(" "),s("p",[t._v("题目：不包含相同字符的两个字符串words[i]和words[j]的长度乘积的最大值")]),t._v(" "),s("p",[t._v("分析：")]),t._v(" "),s("p",[t._v("可以将长度为26的布尔型数组用26个二进制的数位代替，二进制的0对应布尔值false，而1对应true。")]),t._v(" "),s("p",[t._v("如果包含相同的字符，对应的整数与运算不等于0。")]),t._v(" "),s("p",[t._v("如果数组words的长度为n，平均每个字符串的长度为k，那么这种解法的时间复杂度是O（nk+n2），空间复杂度是O（n）")]),t._v(" "),s("h2",{attrs:{id:"数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),s("p",[t._v("技巧：")]),t._v(" "),s("p",[t._v("方向相反的双指针经常用来求排序数组中的两个数字之和。")]),t._v(" "),s("p",[t._v("方向相同的双指针通常用来求正数数组中子数组的和或乘积。")]),t._v(" "),s("p",[t._v("使用滑动窗口双指针解决子数组之和的面试题有一个前提条件——数组中的所有数字都是正数。")]),t._v(" "),s("p",[t._v("如果有负数求连续子数组的话，考虑使用前缀和。")]),t._v(" "),s("h3",{attrs:{id:"面试题6-排序数组中的两个数字之和"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题6-排序数组中的两个数字之和"}},[t._v("#")]),t._v(" 面试题6：排序数组中的两个数字之和")]),t._v(" "),s("p",[t._v("暴力法:  O(n^2)")]),t._v(" "),s("p",[t._v("暴力+二分: O(n log n)")]),t._v(" "),s("p",[t._v("哈希表：O(n)")]),t._v(" "),s("p",[t._v("双指针: O(n)")]),t._v(" "),s("p",[t._v("指针P1初始化指向数组的第1个（下标为0）数字，指针P2初始化指向数组的最后一个数字。")]),t._v(" "),s("h3",{attrs:{id:"面试题7-数组中和为0的3个数字-三数之和"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题7-数组中和为0的3个数字-三数之和"}},[t._v("#")]),t._v(" 面试题7：数组中和为0的3个数字（三数之和）")]),t._v(" "),s("p",[t._v("注意不包含重复的三元组")]),t._v(" "),s("p",[t._v("前面只需要O（n）时间在数组中找出和为给定值的两个数字的方法只适用于排序数组。可是这个题目并没有说给出的数组是排序的，因此需要先对数组排序。排序算法的时间复杂度通常是O（nlogn），因此这种解法的总的时间复杂度是O（nlogn）+O（n2），仍然是O（n2）。")]),t._v(" "),s("p",[t._v("去重：")]),t._v(" "),s("p",[t._v("在找到一个和为0的三元组之后，就需要移动这两个指针，以便找出其他符合条件的三元组。在移动指针的时候需要跳过所有相同的值，以便过滤掉重复的三元组。")]),t._v(" "),s("h3",{attrs:{id:"面试题8-和大于或等于k的最短子数组-连续子数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题8-和大于或等于k的最短子数组-连续子数组"}},[t._v("#")]),t._v(" 面试题8：和大于或等于k的最短子数组（连续子数组）")]),t._v(" "),s("p",[t._v("滑动窗口：指针P1和P2初始化的时候都指向数组的第1个元素")]),t._v(" "),s("p",[t._v("当指针P1和P2之间的子数组数字之和小于k时，向右移动指针P2，直到两个指针之间的子数组数字之和大于k，否则向右移动指针P1，直到两个指针之间的子数组数字之和小于k")]),t._v(" "),s("h3",{attrs:{id:"面试题9-乘积小于k的子数组-连续子数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题9-乘积小于k的子数组-连续子数组"}},[t._v("#")]),t._v(" 面试题9：乘积小于k的子数组（连续子数组）")]),t._v(" "),s("p",[t._v("用指针P1和P2指向数组中的两个数字，两个指针之间的数字组成一个子数组。指针P1永远不会走到指针P2的右边。两个指针初始化都指向数组的第1个数字（下标为0的数字）。 如果两个指针之间的子数组中数字的乘积小于k，则向右移动指针P2。向右移动指针P2相当于在子数组中添加一个新的数字，由于数组中的数字都是正整数，因此子数组中数字的乘积就会变大。")]),t._v(" "),s("p",[t._v("由于我们的目标是求出所有数字乘积小于k的子数组的个数，一旦向右移动指针P1到某个位置时子数组的乘积小于k，就不需要再向右移动指针P1。这是因为只要保持指针P2不动，向右移动指针P1形成的所有子数组的数字乘积就一定小于k。")]),t._v(" "),s("h3",{attrs:{id:"面试题10-和为k的子数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题10-和为k的子数组"}},[t._v("#")]),t._v(" 面试题10：和为k的子数组")]),t._v(" "),s("p",[t._v("前缀和：空间换时间")]),t._v(" "),s("p",[t._v("数组的前i个数字之和记为x。如果存在一个j（j＜i），数组的前j个数字之和为x-k，那么数组中从第i+1个数字开始到第j个数字结束的子数组之和为k。")]),t._v(" "),s("p",[t._v("不但要保存前i个数字之和，还要保存每个和出现的次数，哈希表的键是前i个数字之和，值为每个和出现的次数")]),t._v(" "),s("h3",{attrs:{id:"面试题11-0和1个数相同的子数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题11-0和1个数相同的子数组"}},[t._v("#")]),t._v(" 面试题11：0和1个数相同的子数组")]),t._v(" "),s("p",[t._v("首先把输入数组中所有的0都替换成-1，那么题目就变成求包含相同数目的-1和1的最长子数组的长度。\n如果数组中前i个数字之和为m，前j个数字（j>i）之和也为m，那么从第i+1个数字到第j个数字的子数组的数字之和为0，这个和为0的子数组的长度是j-i。")]),t._v(" "),s("p",[t._v("哈希表的键是从第1个数字开始累加到当前扫描到的数字之和，而值是当前扫描的数字的下标。")]),t._v(" "),s("h3",{attrs:{id:"面试题12-左右两边子数组的和相等"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题12-左右两边子数组的和相等"}},[t._v("#")]),t._v(" 面试题12：左右两边子数组的和相等")]),t._v(" "),s("p",[t._v("前缀和遍历")]),t._v(" "),s("p",[t._v("i数字后面的部分和，等于数组中所有数字之和减去从第1个数字累加到第i个数字的和。")]),t._v(" "),s("h3",{attrs:{id:"面试题13-二维子矩阵的数字之和"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题13-二维子矩阵的数字之和"}},[t._v("#")]),t._v(" 面试题13：二维子矩阵的数字之和")]),t._v(" "),s("p",[t._v("这种累加数组中前面若干数字之和的思路，不仅适用于一维数组，还适用于二维数组。")]),t._v(" "),s("h2",{attrs:{id:"字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[t._v("#")]),t._v(" 字符串")]),t._v(" "),s("h3",{attrs:{id:"面试题14-字符串中的变位词"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题14-字符串中的变位词"}},[t._v("#")]),t._v(" 面试题14：字符串中的变位词")]),t._v(" "),s("p",[t._v("出现字母和字母的次数完全相同即变位词")]),t._v(" "),s("p",[t._v("字典统计+滑动窗口")]),t._v(" "),s("h3",{attrs:{id:"面试题15-字符串中的所有变位词"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题15-字符串中的所有变位词"}},[t._v("#")]),t._v(" 面试题15：字符串中的所有变位词")]),t._v(" "),s("p",[t._v("同14")]),t._v(" "),s("h3",{attrs:{id:"面试题16-不含重复字符的最长子字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题16-不含重复字符的最长子字符串"}},[t._v("#")]),t._v(" 面试题16：不含重复字符的最长子字符串")]),t._v(" "),s("p",[t._v("避免多次重复扫描counts")]),t._v(" "),s("p",[t._v("双指针+hash")]),t._v(" "),s("h3",{attrs:{id:"面试题17-包含所有字符的最短字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题17-包含所有字符的最短字符串"}},[t._v("#")]),t._v(" 面试题17：包含所有字符的最短字符串")]),t._v(" "),s("p",[t._v("双指针+hash")]),t._v(" "),s("h2",{attrs:{id:"回文字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回文字符串"}},[t._v("#")]),t._v(" 回文字符串")]),t._v(" "),s("p",[t._v("一个指针从第1个字符开始从前向后移动，另一个指针从最后一个字符开始从后向前移动。如果两个指针指向的字符相同，则同时移动这两个指针以判断它们指向的下一个字符是否相同。这样一直移动下去，直到两个指针相遇。")]),t._v(" "),s("h3",{attrs:{id:"面试题18-有效的回文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题18-有效的回文"}},[t._v("#")]),t._v(" 面试题18：有效的回文")]),t._v(" "),s("p",[t._v("题目要求只考虑字母和数字字符，如果某个指针指向的字符既不是字母也不是数字，则移动指针跳过该字符。同时，由于题目要求忽略大小写，因此需要把所有的字母都转化成小写形式（或大写形式）再做比较。")]),t._v(" "),s("h3",{attrs:{id:"面试题19-最多删除一个字符得到回文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题19-最多删除一个字符得到回文"}},[t._v("#")]),t._v(" 面试题19：最多删除一个字符得到回文")]),t._v(" "),s("p",[t._v("由于事先不知道应该删除两个不同字符中的哪一个，因此两个字符都可以进行尝试")]),t._v(" "),s("h3",{attrs:{id:"面试题20-回文子字符串的个数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题20-回文子字符串的个数"}},[t._v("#")]),t._v(" 面试题20：回文子字符串的个数")]),t._v(" "),s("p",[t._v("从字符串的中心开始向两端延伸。")]),t._v(" "),s("p",[t._v("长度为奇数的回文的对称中心只有一个字符，而长度为偶数的回文的对称中心有两个字符。")]),t._v(" "),s("p",[t._v("字符串的下标为i。第i个字符本身可以成为长度为奇数的回文子字符串的对称中心，同时第i个字符和第i+1个字符可以一起成为长度为偶数的回文子字符串的对称中心。")]),t._v(" "),s("p",[t._v("for循环通过对每个下标i调用两次countPalindrome来统计回文子字符串的个数。")]),t._v(" "),s("h2",{attrs:{id:"链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),s("p",[t._v("哨兵节点是为了简化处理链表边界条件而引入的附加链表节点")]),t._v(" "),s("p",[t._v("用哨兵节点简化链表插入操作——将新创建的一个哨兵节点当作链表的头节点，链表无论如何也不会为空，因此不需要使用if语句来单独处理输入头节点head为null的情形。哨兵节点简化了代码的逻辑。")]),t._v(" "),s("p",[t._v("用哨兵节点简化链表删除操作")]),t._v(" "),s("h3",{attrs:{id:"面试题21-删除倒数第k个节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题21-删除倒数第k个节点"}},[t._v("#")]),t._v(" 面试题21：删除倒数第k个节点")]),t._v(" "),s("p",[t._v("快k步快慢指针")]),t._v(" "),s("h3",{attrs:{id:"面试题22-链表中环的入口节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题22-链表中环的入口节点"}},[t._v("#")]),t._v(" 面试题22：链表中环的入口节点")]),t._v(" "),s("p",[t._v("二倍速快慢指针")]),t._v(" "),s("p",[t._v("若知道环的个数：")]),t._v(" "),s("ul",[s("li",[t._v("如果链表中的环有n个节点，第1个指针P1先在链表中向前移动n步，然后两个指针以相同的速度向前移动。当第2个指针P2指向环的入口节点时，指针P1已经围绕环走了一圈又回到了入口节点。")]),t._v(" "),s("li",[t._v("环个数——可以从这个相遇的节点出发一边继续向前移动一边计数，当再次回到这个节点时就可以得到环中节点的数目。")])]),t._v(" "),s("p",[t._v("若不知环个数：")]),t._v(" "),s("ul",[s("li",[t._v("两个指针相遇时快的指针多走的步数k一定是环中节点的数目的整数倍，此时慢的指针走过的步数k也是环中节点数的整数倍。")]),t._v(" "),s("li",[t._v("让一个指针指向相遇的节点，该指针的位置是之前慢的指针走了k步到达的位置。接着让另一个指针指向链表的头节点，然后两个指针以相同的速度一起朝着指向下一个节点的指针移动，当后面的指针到达环的入口节点时，前面的指针比它多走了k步，而k是环中节点的数目的整数倍，相当于前面的指针在环中转了k圈后也到达环的入口节点，两个指针正好相遇。也就是说，两个指针相遇的节点正好是环的入口节点。")])]),t._v(" "),s("h3",{attrs:{id:"面试题23-两个链表的第1个重合节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题23-两个链表的第1个重合节点"}},[t._v("#")]),t._v(" 面试题23：两个链表的第1个重合节点")]),t._v(" "),s("p",[t._v("可以在重合的两个链表的基础上构造一个包含环的链表")]),t._v(" "),s("p",[t._v("如果把尾节点的next指针连接到第2个链表的头节点上，那么就可以构造出一个包含环的链表")]),t._v(" "),s("p",[t._v("接下来只需要从第1个链表的头节点开始找出环的入口节点（值为4的节点），该入口节点就是原来两个链表的第1个重合节点。")]),t._v(" "),s("p",[t._v("法2：")]),t._v(" "),s("ul",[s("li",[t._v("首先遍历两个链表得到它们的长度，这样就能知道哪个链表比较长，以及长的链表比短的链表多几个节点。在第2次遍历时，第1个指针P1在较长的链表中先移动若干步，再把第2个指针P2初始化到较短的链表的头节点，然后这两个指针按照相同的速度在链表中移动，直到它们相遇。两个指针相遇的节点就是两个链表的第1个公共节点。")])]),t._v(" "),s("h2",{attrs:{id:"反转链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#反转链表"}},[t._v("#")]),t._v(" 反转链表")]),t._v(" "),s("p",[t._v("有些面试题只有从链表尾节点开始遍历到头节点才容易解决。这个时候可以先将链表反转，然后在反转的链表中从头到尾遍历，这就相当于在原来的链表中从尾到头遍历。")]),t._v(" "),s("h3",{attrs:{id:"面试题24-反转链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题24-反转链表"}},[t._v("#")]),t._v(" 面试题24：反转链表")]),t._v(" "),s("p",[t._v("三指针")]),t._v(" "),s("h3",{attrs:{id:"面试题25-链表中的数字相加"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题25-链表中的数字相加"}},[t._v("#")]),t._v(" 面试题25：链表中的数字相加")]),t._v(" "),s("p",[t._v("先把两个表示整数的链表反转，再在两个反转之后的链表中逐个节点实现加法，最后把表示和的链表反转。")]),t._v(" "),s("h3",{attrs:{id:"面试题26-重排链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题26-重排链表"}},[t._v("#")]),t._v(" 面试题26：重排链表")]),t._v(" "),s("p",[t._v("快慢指针找中点，变量slow指向的节点的下一个节点就是后半段的头节点，用变量temp表示。然后调用函数reverseList反转链表的后半段。")]),t._v(" "),s("h3",{attrs:{id:"面试题27-回文链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题27-回文链表"}},[t._v("#")]),t._v(" 面试题27：回文链表")]),t._v(" "),s("p",[t._v("如果把链表分为前后两半，那么前半段链表反转之后与后半段链表是相同的")]),t._v(" "),s("h3",{attrs:{id:"面试题28-展平多级双向链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面试题28-展平多级双向链表"}},[t._v("#")]),t._v(" 面试题28：展平多级双向链表")]),t._v(" "),s("p",[t._v("由于子链表中的节点也可能有子链表，因此这里的链表是一个递归的结构")])])}),[],!1,null,null,null);a.default=n.exports}}]);