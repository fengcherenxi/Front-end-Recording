(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{613:function(t,s,a){"use strict";a.r(s);var n=a(17),_=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-v8的垃圾回收机制是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-v8的垃圾回收机制是怎样的"}},[t._v("#")]),t._v(" 1. V8的垃圾回收机制是怎样的")]),t._v(" "),a("p",[t._v("V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。")]),t._v(" "),a("p",[a("strong",[t._v("（1）新生代算法")])]),t._v(" "),a("p",[t._v("新生代中的对象——存活时间短，使用 Scavenge GC 算法。")]),t._v(" "),a("p",[t._v("新生代空间——内存空间分为 From 和 To 空间。两个空间中一个空间使用另一个空闲。新分配的对象放入 From，占满时新生代 GC 启动。")]),t._v(" "),a("p",[t._v("算法会检查 From 中存活的对象并复制到 To 中，如果有失活对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。")]),t._v(" "),a("p",[a("strong",[t._v("（2）老生代算法")])]),t._v(" "),a("p",[t._v("老生代中的对象——存活时间长且数量多")]),t._v(" "),a("ul",[a("li",[t._v("标记清除算法")]),t._v(" "),a("li",[t._v("标记压缩算法。")])]),t._v(" "),a("p",[t._v("什么情况下对象会出现在老生代空间中：")]),t._v(" "),a("ul",[a("li",[t._v("经历过一次 Scavenge 算法，从新生代空间移到老生代空间中。")])]),t._v(" "),a("ul",[a("li",[t._v("To 空间的对象占比大小超过 25 %。为不影响到内存分配，迁移。")])]),t._v(" "),a("p",[t._v("老生代中的空间很复杂，有如下几个空间")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("enum")]),t._v(" AllocationSpace "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TODO(v8:7464): Actually map this space's memory as read-only.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不变的对象空间")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NEW_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新生代用于 GC 复制算法的空间")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("OLD_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 老生代常驻对象空间")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CODE_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 老生代代码对象空间")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MAP_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 老生代 map 对象")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 老生代大空间对象")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NEW_LO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新生代大空间对象")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FIRST_SPACE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LAST_SPACE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NEW_LO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FIRST_GROWABLE_PAGED_SPACE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("OLD_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LAST_GROWABLE_PAGED_SPACE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MAP_SPACE")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("在老生代中，以下情况会先启动标记清除算法：")]),t._v(" "),a("ul",[a("li",[t._v("某一个空间没有分块")]),t._v(" "),a("li",[t._v("空间中对象超过一定限制")]),t._v(" "),a("li",[t._v("空间不能保证新生代中的对象移动到老生代中")])]),t._v(" "),a("p",[t._v("会遍历堆中所有对象，标记活对象，销毁所有没有被标记的对象。\n在标记大型堆内存时，可能需要几百毫秒才能完成一次。导致性能问题。\n为解决该问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。")]),t._v(" "),a("p",[t._v("清除对象会造成堆内存出现碎片，当碎片超过限制启动压缩算法。\n压缩过程——将活对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。")]),t._v(" "),a("h2",{attrs:{id:"_2-内存泄漏的相关操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-内存泄漏的相关操作"}},[t._v("#")]),t._v(" 2. 内存泄漏的相关操作？")]),t._v(" "),a("ul",[a("li",[t._v("使用未声明的变量，意外创建全局变量，一直留在内存中无法被回收。")]),t._v(" "),a("li",[t._v("设置了 setInterval 定时器，忘记取消，若循环函数对外部变量有引用，无法被回收。")]),t._v(" "),a("li",[t._v("获取 DOM 元素的引用，元素删除，由于保留了对元素的引用，也无法被回收。")]),t._v(" "),a("li",[t._v("不合理的使用闭包。")])]),t._v(" "),a("h2",{attrs:{id:"_3-更多"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-更多"}},[t._v("#")]),t._v(" 3. 更多")]),t._v(" "),a("p",[t._v("红宝书第四章有关于垃圾回收机制的解释")])])}),[],!1,null,null,null);s.default=_.exports}}]);