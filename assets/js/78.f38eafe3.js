(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{657:function(_,t,a){"use strict";a.r(t);var v=a(17),r=Object(v.a)({},(function(){var _=this,t=_.$createElement,a=_._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"_4-1-基本类型和引用类型的值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-基本类型和引用类型的值"}},[_._v("#")]),_._v(" 4.1 基本类型和引用类型的值")]),_._v(" "),a("p",[_._v("在操作对象时，实际上是在操作对象的引用而不是实际的对象。引用类型的值是按引用访问的。")]),_._v(" "),a("h3",{attrs:{id:"_4-1-1-动态的属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-1-动态的属性"}},[_._v("#")]),_._v(" 4.1.1 动态的属性")]),_._v(" "),a("p",[_._v("对于引用类型的值，可为其添加属性和方法、改变和删除其属性和方法。不能给基本类型的值添加属性，不会导致错误。")]),_._v(" "),a("p",[_._v("基本类型值在内存中占据固定大小的空间，因此保存在栈中；引用类型的值是对象保存堆中.")]),_._v(" "),a("h3",{attrs:{id:"_4-1-2-复制变量值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-2-复制变量值"}},[_._v("#")]),_._v(" 4.1.2 复制变量值")]),_._v(" "),a("p",[_._v("基本类型：两个变量可以参与任何操作而不会相互影响。")]),_._v(" "),a("p",[_._v("引用类型：值的副本是一个指针，指针指向堆中的一个对象。两个变量实际上将引用同一个对象。操作一个变量就会影响另一个变量。")]),_._v(" "),a("h3",{attrs:{id:"_4-1-3-传递参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-3-传递参数"}},[_._v("#")]),_._v(" 4.1.3 传递参数")]),_._v(" "),a("p",[_._v("函数的参数都是按值传递的。")]),_._v(" "),a("p",[_._v("向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。")]),_._v(" "),a("p",[_._v("以上例子说明：说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。")]),_._v(" "),a("h3",{attrs:{id:"_4-1-4-检测类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-4-检测类型"}},[_._v("#")]),_._v(" 4.1.4 检测类型")]),_._v(" "),a("p",[_._v('typeof操作符是确定一个变量是字符串、数值、布尔值，还是undefined的最佳工具。变量的值是一个对象或null，则typeof操作符会返回"object"。使用typeof操作符检测函数时返回"function"。')]),_._v(" "),a("p",[_._v("哪种基本类型可以使用typeof操作符，哪种引用类型用instanceof操作符。")]),_._v(" "),a("p",[_._v("引用类型的值都是Object的实例。在检测一个引用类型值和Object构造函数时会返回true。当然，如果检测基本类型的值返回false，基本类型不是对象。")]),_._v(" "),a("h2",{attrs:{id:"_4-2-执行环境及作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-执行环境及作用域"}},[_._v("#")]),_._v(" 4.2 执行环境及作用域")]),_._v(" "),a("p",[_._v("执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；变量的执行环境有助于确定应该何时释放内存。全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁。")]),_._v(" "),a("p",[_._v("每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。")]),_._v(" "),a("p",[_._v("当代码在一个环境中执行时，会创建变量对象的作用域链。用途是保证对执行环境有权访问的所有变量和函数的有序访问。全局执行环境的变量对象始终都是作用域链中的最后一个对象。")]),_._v(" "),a("p",[_._v("内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。")]),_._v(" "),a("h3",{attrs:{id:"_4-2-1-延长作用域链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1-延长作用域链"}},[_._v("#")]),_._v(" 4.2.1 延长作用域链")]),_._v(" "),a("p",[_._v("有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。就是当执行流进入下列任何一个语句时，作用域链就会得到加长：")]),_._v(" "),a("ul",[a("li",[_._v("try-catch语句的catch块；")]),_._v(" "),a("li",[_._v("with语句。")])]),_._v(" "),a("p",[_._v("当在with语句中引用变量href时（实际引用的是location.href），可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中。至于with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。")]),_._v(" "),a("h3",{attrs:{id:"_4-2-2-没有块级作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-没有块级作用域"}},[_._v("#")]),_._v(" 4.2.2 没有块级作用域")]),_._v(" "),a("p",[_._v("如果是在C、C++或Java中，color会在if语句执行完毕后被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。在使用for语句时尤其要牢记这一差异。")]),_._v(" "),a("p",[_._v("有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。")]),_._v(" "),a("p",[_._v("var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。")]),_._v(" "),a("h2",{attrs:{id:"_4-3-垃圾收集"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-垃圾收集"}},[_._v("#")]),_._v(" 4.3 垃圾收集")]),_._v(" "),a("p",[_._v("JavaScript具有自动垃圾收集机制。收集机制：找出那些不再继续使用的变量，然后释放其占用的内存。收集器会按照固定的时间间隔（或代码执行中预定的收集时间）周期性执行。")]),_._v(" "),a("h3",{attrs:{id:"_4-3-1-标记清除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-标记清除"}},[_._v("#")]),_._v(" 4.3.1 标记清除")]),_._v(" "),a("p",[_._v("是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。")]),_._v(" "),a("p",[_._v("只不过垃圾收集的时间间隔互有不同。")]),_._v(" "),a("h3",{attrs:{id:"_4-3-2-引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-引用计数"}},[_._v("#")]),_._v(" 4.3.2 引用计数")]),_._v(" "),a("p",[_._v("跟踪记录每个值被引用的次数。")]),_._v(" "),a("p",[_._v("值引用次数变成0时将占用的内存回收。")]),_._v(" "),a("p",[_._v("问题：循环引用。为此，Netscape在Navigator 4.0中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。")]),_._v(" "),a("p",[_._v("IE中有一部分对象并不是原生JavaScript。例如，其BOM和DOM中的对象就是使用C++以COM（Component Object Model，组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用引用计数策略。因此即使IE的JavaScript引擎是使用标记清除策略，但JavaScript访问的COM对象是基于引用计数。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。为了解决上述问题，IE9把BOM和DOM对象都转换成了真正的JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。")]),_._v(" "),a("h3",{attrs:{id:"_4-3-3-性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-3-性能问题"}},[_._v("#")]),_._v(" 4.3.3 性能问题")]),_._v(" "),a("p",[_._v("IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使IE7重写了其垃圾收集例程。")]),_._v(" "),a("p",[_._v("改进：临界值被调整为动态修正。如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。")]),_._v(" "),a("h3",{attrs:{id:"_4-3-4-管理内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-4-管理内存"}},[_._v("#")]),_._v(" 4.3.4 管理内存")]),_._v(" "),a("p",[_._v("分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。")]),_._v(" "),a("p",[_._v("优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。数据不再有用通过将其值设置为null来释放其引用——解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。")]),_._v(" "),a("p",[_._v("解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。")]),_._v(" "),a("p",[_._v("解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。")])])}),[],!1,null,null,null);t.default=r.exports}}]);